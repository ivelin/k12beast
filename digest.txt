Directory structure:
└── ivelin-k12beast/
    ├── README.md
    ├── LICENSE
    ├── components.json
    ├── git-digest.sh
    ├── next.config.ts
    ├── package.json
    ├── postcss.config.js
    ├── tailwind.config.js
    ├── tsconfig.json
    ├── public/
    ├── scripts/
    │   ├── dbMigrations.js
    │   ├── migrate.js
    │   ├── migrationUtils.js
    │   └── migrations/
    │       ├── migrationV1.js
    │       ├── migrationV10.js
    │       ├── migrationV11.js
    │       ├── migrationV2.js
    │       ├── migrationV3.js
    │       ├── migrationV4.js
    │       ├── migrationV5.js
    │       ├── migrationV6.js
    │       ├── migrationV7.js
    │       ├── migrationV8.js
    │       └── migrationV9.js
    └── src/
        ├── audio-utils.ts
        ├── middleware.ts
        ├── app/
        │   ├── globals.css
        │   ├── layout.metadata.tsx
        │   ├── layout.tsx
        │   ├── page.tsx
        │   ├── api/
        │   │   ├── auth/
        │   │   │   └── user/
        │   │   │       └── route.ts
        │   │   ├── examples/
        │   │   │   └── route.ts
        │   │   ├── quiz/
        │   │   │   └── route.ts
        │   │   ├── session/
        │   │   │   └── [sessionId]/
        │   │   │       └── route.ts
        │   │   ├── tutor/
        │   │   │   └── route.ts
        │   │   ├── upload-image/
        │   │   │   └── route.ts
        │   │   └── validate/
        │   │       └── route.ts
        │   ├── chat/
        │   │   ├── QuizSection.tsx
        │   │   └── page.tsx
        │   ├── history/
        │   │   ├── SessionItem.tsx
        │   │   └── page.tsx
        │   └── session/
        │       └── [sessionId]/
        │           └── page.tsx
        ├── components/
        │   ├── lib/
        │   │   └── audio-utils.ts
        │   └── ui/
        │       ├── audio-visualizer.tsx
        │       ├── button.tsx
        │       ├── card.tsx
        │       ├── chat-message.tsx
        │       ├── chat.tsx
        │       ├── collapsible.tsx
        │       ├── copy-button.tsx
        │       ├── dialog.tsx
        │       ├── file-preview.tsx
        │       ├── input.tsx
        │       ├── interrupt-prompt.tsx
        │       ├── label.tsx
        │       ├── markdown-renderer.tsx
        │       ├── message-input.tsx
        │       ├── message-list.tsx
        │       ├── prompt-suggestions.tsx
        │       ├── sonner.tsx
        │       ├── textarea.tsx
        │       └── typing-indicator.tsx
        ├── hooks/
        │   ├── use-audio-recording.ts
        │   ├── use-auto-scroll.ts
        │   ├── use-autosize-textarea.ts
        │   └── use-copy-to-clipboard.ts
        ├── store/
        │   └── index.ts
        ├── supabase/
        │   ├── browserClient.ts
        │   ├── config.toml
        │   ├── serverClient.ts
        │   └── functions/
        │       ├── local-sql.sql
        │       └── execute-sql/
        │           └── index.ts
        └── utils/
            ├── errorHandler.ts
            ├── index.ts
            ├── xaiClient.ts
            └── xaiUtils.ts

================================================
File: README.md
================================================
# K12Beast

K12Beast is a personalized tutoring app for K12 students, designed to help them master concepts through tailored lessons, examples, and quizzes based on their test results. 

The student experience follows this flow: 
  - **Student Registration/Login**: Students register or log in to access the app.
  - **New Chat Session**: Students start a new chat session to begin their learning journey.
  - **Problem Submission with Optional Student Solution**: Students input a problem and optionally a proposed solution via text or images.
  - **AI Problem Evaluation and Solution Comments**: The AI evaluates the problem and the student’s proposed solution (if provided), offering comments on correctness and areas for improvement.
  - **Personalized Tutoring Lesson**: The AI delivers a tailored lesson based on the problem and the student’s performance.
  - **More Similar Problem Examples**: Upon request, the AI provides additional problem examples with solutions for self-study.
  - **Quizzes**: Upon request, the AI offers quizzes for self-testing to reinforce learning.
  - **End Session**: Students end the session when they feel ready.
  - **Share Session with Parents**: Students can share the session with their parents or teachers for review.

Built with Super Grok 3, Next.js, it leverages Supabase (or any PostgreSQL database) for data storage and the Grok/X xAI API for generating educational content. 
This guide will walk you through setting up a local instance of the app from scratch.

## Prerequisites

Before setting up K12Beast, ensure you have the following tools and accounts:

- **Node.js and npm**: Version 18.x or later. Download from [nodejs.org](https://nodejs.org).
- **Git**: To clone the repository. Install from [git-scm.com](https://git-scm.com).
- **Supabase Account**: For database and storage (optional if using another PostgreSQL instance). Sign up at [supabase.com](https://supabase.com).
- **PostgreSQL**: Version 14.x or later, if not using Supabase. Install from [postgresql.org](https://www.postgresql.org).
- **xAI API Key**: For generating tutoring content. Request access at [x.ai](https://x.ai).
- **Text Editor**: Such as VS Code, for editing code.
- **Browser**: A modern browser like Chrome or Firefox to test the app.


## Cloning the Repository

To get started, clone the K12Beast repository to your local machine:

1. Open a terminal and run the following command to clone the repo:
    ```
    git clone https://github.com/ivelin/k12beast.git
    ```
1. Navigate to the project directory:
    ```
    cd k12beast
    ```

## Setting Up Environment Variables

K12Beast requires environment variables to connect to Supabase (or PostgreSQL) and the xAI API. Follow these steps:

1. Create a `.env.local` file in the root of the project:
    ```
    touch .env.local
    ```
1. Open `.env.local` in a text editor and add the following variables:
    ```
    NEXT_PUBLIC_SUPABASE_URL=your-supabase-url
    NEXT_PUBLIC_SUPABASE_ANON_KEY=your-supabase-anon-key
    SUPABASE_SERVICE_ROLE_KEY=your-supabase-service-role-key
    XAI_API_KEY=your-xai-api-key
    XAI_MODEL_NAME=grok-2-vision-1212 ---(or a more recent model)---
    ```
    - Replace `your-supabase-url` and `your-supabase-anon-key` with values from your Supabase project’s API settings.
    - Replace `your-supabase-service-role-key` with the service role key (keep this secret, do not expose in client-side code).
    - Replace `your-xai-api-key` with your xAI API key.
1. Save the file. These variables will be loaded automatically by the app.

## Installing Dependencies

K12Beast uses Node.js dependencies managed by npm. Install them with the following steps:

1. Ensure you are in the project directory (`k12beast`).
1. Run the following command to install all dependencies:
    ```
    npm install
    ```
1. After installation, you’ll see a message reminding you to set up your environment variables if you haven’t already. Ensure `.env.local` is configured as described in the previous section.
1. The `node_modules` directory and `package-lock.json` will be created, containing all required packages.





## Setting Up Supabase/PostgreSQL

K12Beast uses a PostgreSQL database, which can be hosted via Supabase or any PostgreSQL instance. Follow these steps:

1. **Using Supabase (Cloud)**:
   - Log in to your Supabase account and create a new project.
   - Note your project’s URL and anon key from the API settings.
   - In the Supabase dashboard, go to "Project Settings" > "API" to find your service role key.
   - Deploy the `execute-sql` Edge Function:
     - Copy the code from `src/supabase/functions/execute-sql/index.ts`.
     - In the Supabase dashboard, go to "Edge Functions," create a new function named `execute-sql`, and paste the code.
     - Deploy the function.
   - Apply the local SQL functions:
     - Copy the code from `src/supabase/functions/local-sql.sql`.
     - In the Supabase dashboard, go to the "SQL Editor," paste the code, and run it. This sets up necessary functions and permissions, such as `validate_user_id`, which are required for migrations that interact with the `auth` schema (e.g., linking sessions to users).

2. **Using a Local Supabase Instance**:
  - Ensure you have the Supabase CLI installed. Install it via npm if needed:
    ```
    npm install -g supabase
    ```
  - Start your local Supabase instance:    
    ```
    supabase start
    ```
  - Deploy the `execute-sql` Edge Function locally:
    - The `execute-sql` function is located at `src/supabase/functions/execute-sql/index.ts`.
    - Use the Supabase CLI to deploy it:
      ```
      supabase functions deploy execute-sql --project-ref local
      ```
  - Note: `project-ref local` assumes your local Supabase instance is running. If you encounter issues, ensure your Supabase CLI is logged in and linked to your project (use `supabase login` and `supabase link` if needed).
  - Apply the local SQL functions:
    - Run the following command to apply `local-sql.sql` to your local database:      
      ```
      psql -h localhost -p 54322 -U postgres -d k12beast -f src/supabase/functions/local-sql.sql
      ```

Adjust the host, port, and user as needed based on your `src/supabase/config.toml` settings (default port for local Supabase is 54322).

3. **Using a Local PostgreSQL Instance (Without Supabase)**:
  - Install PostgreSQL if not already installed.
  - Create a new database:
    ```
    createdb k12beast
    ```
  - Apply the local SQL functions:
  - Run the following command to apply `local-sql.sql` to your database:
    ```
    psql -h localhost -p 5432 -U postgres -d k12beast -f src/supabase/functions/local-sql.sql
    ```

Adjust the host, port, and user as needed based on your PostgreSQL setup.
- Update `.env.local` with your PostgreSQL connection details instead of Supabase keys (you may need to adjust the app’s Supabase client setup in `src/supabase/serverClient.ts` and `src/supabase/browserClient.ts` to use a direct PostgreSQL connection).
- Note: If using a local PostgreSQL instance without Supabase, the `execute-sql` Edge Function is not applicable, and you’ll need to modify the migration scripts (`scripts/migrationUtils.js`) to execute SQL directly against your PostgreSQL database instead of using an Edge Function.

4. Ensure your database is running and accessible with the credentials provided in `.env.local`.    



## Running Database Migrations

K12Beast automatically runs database migrations on startup to set up the required schema. Here’s what happens:

1. When you start the app (via `npm run dev` or `npm start`), the `scripts/migrate.js` script is executed automatically.

2. The migration script will:
   - Connect to your Supabase or PostgreSQL database using the credentials in `.env.local`.
   - Create necessary tables like `sessions`, `migrations`, and `db_app_version_compatibility`.
   - Apply any pending migrations (e.g., adding columns like `completed`, `notes`).

3. If migrations fail (e.g., due to network issues or missing environment variables), the app will not start, and you’ll see an error message. Check the troubleshooting section for solutions.

4. You don’t need to run migrations manually unless debugging; they are handled on startup.

## Starting the Development Server

Once your environment is set up, you can start the K12Beast development server:

1. Ensure your Supabase or PostgreSQL database is running and accessible.
1. Start the development server with the following command:
    ```
    npm run dev
    ```
1. The app will:
- Run database migrations automatically (as described in the previous section).
- Start a Next.js development server on `http://localhost:3000`.
1. Open your browser and navigate to `http://localhost:3000` to access the app.
1. You should see the login page. Sign up or log in to start using K12Beast.

## Navigating the App

- **Chat Page (`/chat`)**: This is the main page where you can submit a problem (text or images) to start a tutoring session. After submitting a problem, you can request more examples, take a quiz, or end the session.
- **Session Detail Page (`/session/[sessionId]`)**: This page displays the details of a specific session, including the original problem, lesson, examples, quizzes, and notes.
- **Session History Page (`/history`)**: This page lists all your past sessions, allowing you to view their details by clicking on a session.

## Troubleshooting

Here are solutions to common issues when setting up K12Beast:

- **Error: "Missing Supabase environment variables"**
  - Ensure `NEXT_PUBLIC_SUPABASE_URL`, `NEXT_PUBLIC_SUPABASE_ANON_KEY`, and `SUPABASE_SERVICE_ROLE_KEY` are set in `.env.local`. Double-check your Supabase project settings for the correct values.

- **Error: "Failed to run database migrations on startup"**
  - Check your internet connection if using Supabase.
  - Verify that the `execute-sql` Edge Function is deployed in Supabase (if applicable).
  - Ensure your database credentials in `.env.local` are correct.

- **Error: "Unexpected error in xAI request"**
  - Confirm that `XAI_API_KEY` is set in `.env.local` and is valid.
  - Check your network connection, as the xAI API requires internet access.

- **App doesn’t load at `http://localhost:3000`**
  - Ensure the development server is running (`npm run dev`).
  - Check for port conflicts; if port 3000 is in use, Next.js will prompt you to use a different port.

## Additional Resources

For more information on the tools and technologies used in K12Beast, check out these resources:

- **Next.js Documentation**: Learn about Next.js features and APIs at [nextjs.org/docs](https://nextjs.org/docs).
- **Supabase Documentation**: Explore Supabase features, including database and Edge Functions, at [supabase.com/docs](https://supabase.com/docs).
- **PostgreSQL Documentation**: For using a local PostgreSQL instance, refer to [postgresql.org/docs](https://www.postgresql.org/docs).
- **xAI API**: Details on the xAI API for generating educational content are available at [x.ai](https://x.ai).
- **React Documentation**: Understand React concepts at [react.dev](https://react.dev).

## Contributions

K12Beast welcomes contributions from the community! Follow these steps to contribute:

1. **Fork the Repository**: Fork the repo on GitHub and clone your fork locally.
1. **Create a Branch**: Create a new branch for your changes.
    ```
    git checkout -b feature/your-feature-name
    ```
1.**Make Changes**: Implement your feature or bug fix, following the project’s coding style (e.g., use TypeScript, adhere to ESLint rules).
1. **Test Your Changes**: Ensure your changes work by running the app (`npm run dev`) and testing locally.
1. **Commit and Push**: Commit your changes with a clear message and push to your fork.
    ```
    git commit -m "Add your descriptive commit message"
    git push origin feature/your-feature-name
    ```
1. **Submit a Pull Request**: Open a pull request (PR) on the main repository. Describe your changes, reference any related issues, and ensure your PR passes any automated checks.
1. **Sign the Contributor License Agreement (CLA)**: By contributing, you agree that your contributions are licensed under the Apache 2.0 License. No formal CLA is required, but ensure your contributions comply with the license terms.
1. **Code of Conduct**: We follow a standard open-source Code of Conduct. Be respectful, inclusive, and collaborative in all interactions.

For questions, reach out by opening an issue on GitHub.


================================================
File: LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.



================================================
File: components.json
================================================
{
    "style": "default",
    "rsc": true,
    "tsx": true,
    "tailwind": {
      "config": "tailwind.config.js",
      "css": "src/app/globals.css",
      "baseColor": "slate",
      "cssVariables": true
    },
    "aliases": {
      "components": "@/components",
      "utils": "@/utils"
    }
  }


================================================
File: git-digest.sh
================================================
#!/bin/bash
# generate_digest.sh
# Creates a digest with a prompt for Grok to infer project details
# Instructions for User: Run this script from the root directory of a local clone of your Git repository.
# The script will fetch the remote URL automatically from your Git config.

# Step 1: Fetch the remote URL dynamically
REMOTE_URL=$(git config --get remote.origin.url)
if [ -z "$REMOTE_URL" ]; then
  echo "Error: No remote.origin.url found. Ensure you're in a Git repo with a remote set."
  exit 1
fi

# Convert common Git URL formats to HTTPS GitHub URL
if [[ "$REMOTE_URL" =~ ^git@ ]]; then
  REPO_URL=$(echo "$REMOTE_URL" | sed 's/git@github.com:/https:\/\/github.com\//' | sed 's/\.git$//')
elif [[ "$REMOTE_URL" =~ ^https:// ]]; then
  REPO_URL=$(echo "$REMOTE_URL" | sed 's/\.git$//')
else
  echo "Error: Unrecognized remote URL format: $REMOTE_URL"
  exit 1
fi

# Configuration
BRANCH=$(git rev-parse --abbrev-ref HEAD)  # Use current branch
BASE_RAW_URL="${REPO_URL}/raw/${BRANCH}/"  # Base URL for raw file access
OUTPUT_FILE="tmp/digest.txt"

# Create output directory and clear the file
mkdir -p tmp
> "$OUTPUT_FILE"

# Step 2: Add Project Summary with Prompt and Memory Instruction
cat << EOF >> "$OUTPUT_FILE"
===== Project Summary =====
Project: [Inferred by Grok]
Base Raw URL: $BASE_RAW_URL
Total Files: (calculated below)
Instructions for Grok: 
- Infer the project description, tech stack, and key directories by analyzing the README (if available) and scanning the files linked below.
- README link (if present): ${BASE_RAW_URL}README.md
- To access any file, prepend the Base Raw URL to the relative paths listed below. For example, 'src/auth/login.ts' becomes '${BASE_RAW_URL}src/auth/login.ts'.
- Use your web search capability if needed to fetch and analyze content.
- Store this digest as my project index for future sessions.
EOF

# Step 3: Generate Relative File Paths and Count Files
echo -e "\n===== File Links (Relative Paths) =====" >> "$OUTPUT_FILE"
COUNT=0
git ls-files | grep -E '\.(ts|tsx|js|jsx|css|md|json|txt)$' | grep -v -E '(package-lock\.json|next-env\.d\.ts|\.gitignore|LICENSE|public/|tmp/|\.env\.local)' > "$OUTPUT_FILE.tmp"
while IFS= read -r file; do
  echo "$file" >> "$OUTPUT_FILE"
  ((COUNT++))
done < "$OUTPUT_FILE.tmp"
rm "$OUTPUT_FILE.tmp"

# Step 4: Update Summary with File Count
sed -i "s/Total Files: (calculated below)/Total Files: $COUNT/" "$OUTPUT_FILE"

# Step 5: Check for README and Adjust if Missing
if ! git ls-files | grep -q "README.md"; then
  sed -i "s/README link (if present): ${BASE_RAW_URL}README.md/README: No README.md found in the repo. Rely on file analysis alone./" "$OUTPUT_FILE"
fi

echo "Digest generated at $OUTPUT_FILE"


================================================
File: next.config.ts
================================================
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  /* config options here */
};

export default nextConfig;



================================================
File: package.json
================================================
{
  "name": "k12beast",
  "version": "0.6.6",
  "private": true,
  "scripts": {
    "dev": "node scripts/migrate.js && next dev",
    "build": "next build",
    "start": "node scripts/migrate.js && next start",
    "lint": "next lint",
    "postinstall": "echo 'Please set up your environment variables in .env.local. See README.md for instructions.'"
  },
  "dependencies": {
    "@radix-ui/react-collapsible": "^1.1.3",
    "@radix-ui/react-dialog": "^1.1.1",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@supabase/supabase-js": "^2.49.4",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.1",
    "dompurify": "^3.2.5",
    "dotenv": "^16.4.5",
    "framer-motion": "^11.18.2",
    "lucide-react": "^0.441.0",
    "next": "15.2.4",
    "next-themes": "^0.4.6",
    "openai": "^4.90.0",
    "react": "^19.0.0",
    "react-device-detect": "^2.2.3",
    "react-dom": "^19.0.0",
    "react-dropzone": "^14.3.8",
    "react-markdown": "^10.1.0",
    "remark-gfm": "^4.0.1",
    "remeda": "^2.21.2",
    "semver": "^7.7.1",
    "shiki": "^1.29.2",
    "sonner": "^2.0.3",
    "tailwind-merge": "^2.5.2",
    "turndown": "^7.2.0",
    "uuid": "^11.1.0",
    "zustand": "^4.5.5"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "autoprefixer": "^10.4.20",
    "eslint": "^9.0.0",
    "eslint-config-next": "15.2.4",
    "postcss": "^8.4.47",
    "tailwindcss": "^4",
    "typescript": "^5"
  }
}


================================================
File: postcss.config.js
================================================
module.exports = {
  plugins: {
    "@tailwindcss/postcss": { config: "./tailwind.config.js" },
    autoprefixer: {},
  },
};


================================================
File: tailwind.config.js
================================================
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
  ],
  prefix: "",
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
    },
  },
  plugins: [], 
};


================================================
File: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts", "scripts/dbMigrations.js", "scripts/migrate.js"],
  "exclude": ["node_modules"]
}



================================================
File: scripts/dbMigrations.js
================================================
// scripts/dbMigrations.js
require("dotenv").config({ path: require("path").resolve(__dirname, "../.env.local") });
const { createClient } = require("@supabase/supabase-js");
const packageJson = require("../package.json");
const {
  executeSql,
  ensureTablesExist,
  getCurrentVersion,
  isAppVersionCompatible,
  acquireLock,
  releaseLock,
} = require("./migrationUtils");

// Validate environment variables before initializing Supabase client
if (!process.env.NEXT_PUBLIC_SUPABASE_URL || !process.env.SUPABASE_SERVICE_ROLE_KEY) {
  console.error("NEXT_PUBLIC_SUPABASE_URL:", process.env.NEXT_PUBLIC_SUPABASE_URL || "Empty");
  console.error(
    "SUPABASE_SERVICE_ROLE_KEY:",
    process.env.SUPABASE_SERVICE_ROLE_KEY
      ? `Non-empty (last 5 chars: ${process.env.SUPABASE_SERVICE_ROLE_KEY.slice(-5)})`
      : "Empty"
  );
  throw new Error(
    "Missing Supabase environment variables. Ensure NEXT_PUBLIC_SUPABASE_URL and " +
    "SUPABASE_SERVICE_ROLE_KEY are set in your .env.local file."
  );
}

// Initialize Supabase client with the service role key
const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);
console.log(
  "Supabase client initialized with key (last 5 chars):",
  process.env.SUPABASE_SERVICE_ROLE_KEY.slice(-5)
);

// Import migration scripts
const migrationV1 = require("./migrations/migrationV1");
const migrationV2 = require("./migrations/migrationV2");
const migrationV3 = require("./migrations/migrationV3");
const migrationV4 = require("./migrations/migrationV4");
const migrationV5 = require("./migrations/migrationV5");
const migrationV6 = require("./migrations/migrationV6");
const migrationV7 = require("./migrations/migrationV7");
const migrationV8 = require("./migrations/migrationV8");
const migrationV9 = require("./migrations/migrationV9");
const migrationV10 = require("./migrations/migrationV10");
const migrationV11 = require("./migrations/migrationV11"); // Added

// Define the app version from package.json
const APP_VERSION = packageJson.version;

// Define the migrations with their required app versions
const migrations = [
  migrationV1,
  migrationV2,
  migrationV3,
  migrationV4,
  migrationV5,
  migrationV6,
  migrationV7,
  migrationV8,
  migrationV9,
  migrationV10,
  migrationV11, // Added
];

// Mapping of database versions to the app version that introduced them
const dbVersionRequiredByAppVersion = [
  { dbVersion: 1, appVersion: "0.0.1" },
  { dbVersion: 2, appVersion: "0.1.0" },
  { dbVersion: 3, appVersion: "0.2.0" },
  { dbVersion: 4, appVersion: "0.3.0" },
  { dbVersion: 5, appVersion: "0.4.0" },
  { dbVersion: 6, appVersion: "0.5.0" },
  { dbVersion: 7, appVersion: "0.6.2" },
  { dbVersion: 8, appVersion: "0.6.3" },
  { dbVersion: 9, appVersion: "0.6.4" },
  { dbVersion: 10, appVersion: "0.6.5" },
  { dbVersion: 11, appVersion: "0.6.6" }, // Added
];

// Run pending migrations
async function runMigrations(instanceId = "default-instance") {
  const lockKey = "migration-lock";

  try {
    await ensureTablesExist(supabase);

    const currentVersion = await getCurrentVersion(supabase);
    console.log(`Running app version: ${APP_VERSION}`);
    console.log(`Current database version: ${currentVersion}`);

    // Check compatibility before migrations
    const { isCompatible: isCompatibleBefore, targetDbVersion } = await isAppVersionCompatible(
      currentVersion,
      migrations,
      APP_VERSION,
      dbVersionRequiredByAppVersion
    );

    let pendingMigrations = [];
    if (!isCompatibleBefore) {
      pendingMigrations = migrations.filter(m => m.version > currentVersion);
      if (pendingMigrations.length === 0) {
        console.log(
          `No pending migrations to run, but app version ${APP_VERSION} requires database ` +
          `version ${targetDbVersion}, while the current database version is ${currentVersion}.`
        );
        throw new Error(
          `App version ${APP_VERSION} requires a database version newer than ${currentVersion}. ` +
          "Please update the app or database schema."
        );
      }
    } else {
      console.log(
        `App version ${APP_VERSION} is compatible with database version ${currentVersion}. ` +
        "Checking for pending migrations..."
      );
      pendingMigrations = migrations.filter(m => m.version > currentVersion);
      if (pendingMigrations.length === 0) {
        console.log("No pending migrations to apply.");
        return;
      }
    }

    const lockAcquired = await acquireLock(lockKey, instanceId, supabase);
    if (!lockAcquired) {
      console.log("Another instance is currently running migrations. Waiting...");
      let retries = 10;
      while (retries > 0) {
        await new Promise(resolve => setTimeout(resolve, 1000));
        const { data } = await supabase
          .from("migration_locks")
          .select("locked")
          .eq("lock_key", lockKey)
          .single();

        if (!data?.locked) {
          const retryLock = await acquireLock(lockKey, instanceId, supabase);
          if (retryLock) break;
        }
        retries--;
      }

      if (retries === 0) {
        throw new Error("Failed to acquire migration lock after multiple attempts.");
      }
    }

    try {
      if (pendingMigrations.length > 0) {
        console.log(
          `Database upgrade required: Upgrading from version ${currentVersion} to version ` +
          `${pendingMigrations[pendingMigrations.length - 1].version} for app version ${APP_VERSION}...`
        );

        for (const migration of pendingMigrations) {
          console.log(
            `Applying migration version ${migration.version} for app version ${migration.appVersion}...`
          );

          if (migration.modifications) {
            for (const sql of migration.modifications) {
              await executeSql(sql, supabase);
            }
          }

          if (migration.apply) {
            await migration.apply(supabase);
          }

          const { error: insertMigrationError } = await supabase
            .from("migrations")
            .insert({ version: migration.version });
          if (insertMigrationError) throw insertMigrationError;

          const { error: insertCompatibilityError } = await supabase
            .from("db_app_version_compatibility")
            .insert({
              db_version: migration.version,
              app_version: migration.appVersion,
              upgraded_at: new Date().toISOString(),
            });
          if (insertCompatibilityError) throw insertCompatibilityError;

          console.log(`Migration version ${migration.version} applied successfully.`);
        }

        console.log("All migrations applied successfully.");
      }

      // Recheck compatibility after migrations
      const newDbVersion = await getCurrentVersion(supabase);
      console.log(`Database version after migrations: ${newDbVersion}`);
      const { isCompatible: isCompatibleAfter } = await isAppVersionCompatible(
        newDbVersion,
        migrations,
        APP_VERSION,
        dbVersionRequiredByAppVersion
      );

      if (!isCompatibleAfter) {
        throw new Error(
          `App version ${APP_VERSION} is not compatible with the database version ${newDbVersion} ` +
          `after applying migrations. Required database version: ${targetDbVersion}. ` +
          "Please update the app to a compatible version."
        );
      }

      console.log(
        `App version ${APP_VERSION} is compatible with the final database version ${newDbVersion}.`
      );
    } catch (error) {
      console.error("Migration failed:", error);
      throw error;
    } finally {
      await releaseLock(lockKey, instanceId, supabase);
    }
  } catch (error) {
    console.error("Error running migrations:", error);
    throw error;
  }
}

module.exports = { runMigrations };


================================================
File: scripts/migrate.js
================================================
// scripts/migrate.js
const { runMigrations } = require("./dbMigrations");

// Run migrations on startup
(async () => {
  try {
    await runMigrations("startup-instance");
    process.exit(0); // Exit successfully
  } catch (error) {
    console.error("Failed to run database migrations on startup:", error);
    console.error(
      "App cannot start due to migration failure. This may be due to a network issue (ENETUNREACH). " +
      "Please check your internet connection, ensure the Supabase Edge Function 'execute-sql' is deployed and accessible, " +
      "and verify that your Supabase URL and service role key in .env.local are correct."
    );
    process.exit(1); // Exit with failure
  }
})();


================================================
File: scripts/migrationUtils.js
================================================
// scripts/migrationUtils.js
const semver = require("semver");

// Execute SQL via the execute-sql Edge Function with retry logic
async function executeSql(sqlText, supabase, retries = 3, delay = 1000) {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const { data, error } = await supabase.functions.invoke("execute-sql", {
        method: "POST",
        body: { sql_text: sqlText },
      });

      if (error) {
        console.error(
          `Edge Function invocation error (attempt ${attempt}/${retries}):`,
          error
        );
        throw new Error(`Failed to invoke Edge Function: ${error.message}`);
      }

      if (data.error) {
        console.error(
          `SQL execution error from Edge Function (attempt ${attempt}/${retries}):`,
          data.error
        );
        throw new Error(`SQL execution failed: ${data.error}`);
      }

      if (!data.success) {
        console.error(
          `SQL execution failed (attempt ${attempt}/${retries}):`,
          JSON.stringify(data, null, 2)
        );
        throw new Error("SQL execution failed without error message");
      }

      return data;
    } catch (error) {
      if (attempt === retries) {
        console.error("Error executing SQL after all retries:", error);
        throw error;
      }
      console.warn(
        `Retrying SQL execution (${attempt}/${retries}) due to error:`,
        error.message
      );
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

// Ensure the required tables exist
async function ensureTablesExist(supabase) {
  try {
    await executeSql(`
      CREATE TABLE IF NOT EXISTS migrations (
        id SERIAL PRIMARY KEY,
        version INTEGER NOT NULL,
        applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `, supabase);

    const { data: migrationsCheck, error: migrationsCheckError } = await supabase
      .from("migrations")
      .select("*")
      .limit(1);
    if (migrationsCheckError && migrationsCheckError.code !== "PGRST116") {
      console.error("Failed to verify migrations table:", migrationsCheckError.message);
      throw new Error(`Failed to verify migrations table: ${migrationsCheckError.message}`);
    }

    await executeSql(`
      CREATE TABLE IF NOT EXISTS db_app_version_compatibility (
        id SERIAL PRIMARY KEY,
        db_version INTEGER NOT NULL,
        app_version TEXT NOT NULL,
        upgraded_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `, supabase);

    const { data: compatibilityCheck, error: compatibilityCheckError } = await supabase
      .from("db_app_version_compatibility")
      .select("*")
      .limit(1);
    if (compatibilityCheckError && compatibilityCheckError.code !== "PGRST116") {
      console.error(
        "Failed to verify db_app_version_compatibility table:",
        compatibilityCheckError.message
      );
      throw new Error(
        `Failed to verify db_app_version_compatibility table: ${compatibilityCheckError.message}`
      );
    }

    await executeSql(`
      CREATE TABLE IF NOT EXISTS migration_locks (
        id SERIAL PRIMARY KEY,
        lock_key TEXT NOT NULL UNIQUE,
        locked BOOLEAN NOT NULL DEFAULT FALSE,
        locked_at TIMESTAMP,
        locked_by TEXT
      );
    `, supabase);

    const { data: locksCheck, error: locksCheckError } = await supabase
      .from("migration_locks")
      .select("*")
      .limit(1);
    if (locksCheckError && locksCheckError.code !== "PGRST116") {
      console.error("Failed to verify migration_locks table:", locksCheckError.message);
      throw new Error(`Failed to verify migration_locks table: ${locksCheckError.message}`);
    }

    await executeSql(`
      CREATE TABLE IF NOT EXISTS sessions (
        id TEXT PRIMARY KEY,
        lesson TEXT,
        examples JSONB,
        quizzes JSONB,
        "performanceHistory" JSONB
      );
    `, supabase);

    const { data: sessionsCheck, error: sessionsCheckError } = await supabase
      .from("sessions")
      .select("*")
      .limit(1);
    if (sessionsCheckError && sessionsCheckError.code !== "PGRST116") {
      console.error("Failed to verify sessions table:", sessionsCheckError.message);
      throw new Error(`Failed to verify sessions table: ${sessionsCheckError.message}`);
    }

    console.log("All required tables ensured and verified.");
  } catch (error) {
    console.error("Error ensuring tables exist:", error);
    throw error;
  }
}

// Get the current database version
async function getCurrentVersion(supabase) {
  try {
    const { data, error } = await supabase
      .from("migrations")
      .select("version")
      .order("version", { ascending: false })
      .limit(1);

    if (error) throw error;

    return data && data.length > 0 ? data[0].version : 0;
  } catch (error) {
    console.error("Error getting current database version:", error);
    throw error;
  }
}

// Check if the app version is compatible with the database version
async function isAppVersionCompatible(dbVersion, migrations, APP_VERSION, dbVersionRequiredByAppVersion) {
  try {
    // Find the highest migration version
    const latestMigration = migrations
      .sort((a, b) => b.version - a.version)[0];

    if (!latestMigration) {
      console.log("No migrations available. Assuming compatibility with database version 0.");
      return { isCompatible: true, targetDbVersion: 0 };
    }

    const highestMigrationVersion = latestMigration.version;

    // Find the required database version for the current app version
    const sortedMapping = [...dbVersionRequiredByAppVersion].sort((a, b) =>
      semver.compare(a.appVersion, b.appVersion)
    );
    let requiredDbVersion = 0;
    for (const entry of sortedMapping) {
      if (semver.gte(APP_VERSION, entry.appVersion)) {
        requiredDbVersion = entry.dbVersion;
      } else {
        break;
      }
    }

    const isCompatible = dbVersion >= requiredDbVersion;

    console.log(
      `App version ${APP_VERSION} requires database version ${requiredDbVersion}. ` +
      `Current database version: ${dbVersion}. Highest migration version: ${highestMigrationVersion}. ` +
      `Compatible: ${isCompatible}`
    );

    return { isCompatible, targetDbVersion: requiredDbVersion };
  } catch (error) {
    console.error("Error checking app version compatibility:", error);
    throw error;
  }
}

// Acquire a migration lock
async function acquireLock(lockKey, instanceId, supabase) {
  try {
    const { error: insertError } = await supabase
      .from("migration_locks")
      .upsert(
        { lock_key: lockKey, locked: false, locked_at: null, locked_by: null },
        { onConflict: "lock_key" }
      );

    if (insertError) throw insertError;

    const { data, error: updateError } = await supabase
      .from("migration_locks")
      .update({ locked: true, locked_at: new Date().toISOString(), locked_by: instanceId })
      .eq("lock_key", lockKey)
      .eq("locked", false)
      .select();

    if (updateError) throw updateError;

    return data && data.length > 0;
  } catch (error) {
    console.error("Error acquiring migration lock:", error);
    throw error;
  }
}

// Release the migration lock
async function releaseLock(lockKey, instanceId, supabase) {
  try {
    const { error } = await supabase
      .from("migration_locks")
      .update({ locked: false, locked_at: null, locked_by: null })
      .eq("lock_key", lockKey)
      .eq("locked_by", instanceId);

    if (error) throw error;
  } catch (error) {
    console.error("Error releasing migration lock:", error);
    throw error;
  }
}

module.exports = {
  executeSql,
  ensureTablesExist,
  getCurrentVersion,
  isAppVersionCompatible,
  acquireLock,
  releaseLock,
};


================================================
File: scripts/migrations/migrationV1.js
================================================
// scripts/migrations/migrationV1.js
module.exports = {
    version: 1,
    appVersion: "0.1.0",
  };


================================================
File: scripts/migrations/migrationV10.js
================================================
// scripts/migrations/migrationV10.js
module.exports = {
    version: 10,
    appVersion: "0.6.5",
    modifications: [
      // Backfill user_id for existing sessions by selecting the first user from auth.users
      // This assumes at least one user exists in auth.users
      "UPDATE sessions SET user_id = (SELECT id FROM auth.users ORDER BY created_at ASC LIMIT 1) WHERE user_id IS NULL AND EXISTS (SELECT 1 FROM auth.users);",
    ],
  };


================================================
File: scripts/migrations/migrationV11.js
================================================
// scripts/migrations/migrationV11.js
module.exports = {
    version: 11,
    appVersion: "0.6.6",
    modifications: [
      `
        CREATE POLICY "Public read access to sessions" ON sessions
        FOR SELECT TO anon
        USING (true);
      `,
    ],
  };


================================================
File: scripts/migrations/migrationV2.js
================================================
// scripts/migrations/migrationV2.js
module.exports = {
  version: 2,
  appVersion: "0.2.0",
  modifications: [
    "ALTER TABLE sessions ADD COLUMN IF NOT EXISTS completed BOOLEAN DEFAULT FALSE;",
    "ALTER TABLE sessions ADD COLUMN IF NOT EXISTS completed_at TIMESTAMP;"
  ]
};


================================================
File: scripts/migrations/migrationV3.js
================================================
// scripts/migrations/migrationV3.js
module.exports = {
  version: 3,
  appVersion: "0.3.0",
  async apply(supabase) {
    try {
      const { data: buckets, error: listError } = await supabase.storage.listBuckets();
      if (listError) {
        console.error("Failed to list buckets:", listError.message);
        throw new Error(`Failed to list buckets: ${listError.message}`);
      }

      const bucketExists = buckets.some(bucket => bucket.name === "problems");
      if (bucketExists) return;

      const { data, error } = await supabase.storage.createBucket("problems", {
        public: true,
      });

      if (error) {
        console.error("Failed to create bucket 'problems':", error.message);
        throw new Error(`Failed to create bucket 'problems': ${error.message}`);
      }
    } catch (err) {
      console.error("Error creating bucket 'problems':", err);
      throw err;
    }
  }
};


================================================
File: scripts/migrations/migrationV4.js
================================================
// scripts/migrations/migrationV4.js
module.exports = {
  version: 4,
  appVersion: "0.3.0",
  modifications: [
    "ALTER TABLE sessions ADD COLUMN IF NOT EXISTS created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP;",
    "ALTER TABLE sessions ADD COLUMN IF NOT EXISTS updated_at TIMESTAMP;"
  ]
};


================================================
File: scripts/migrations/migrationV5.js
================================================
// scripts/migrations/migrationV5.js
module.exports = {
  version: 5,
  appVersion: "0.4.0",
  modifications: [
    "ALTER TABLE sessions ADD COLUMN IF NOT EXISTS notes TEXT;"
  ]
};


================================================
File: scripts/migrations/migrationV6.js
================================================
// scripts/migrations/migrationV6.js
module.exports = {
    version: 6,
    appVersion: "0.5.0",
  };


================================================
File: scripts/migrations/migrationV7.js
================================================
// scripts/migrations/migrationV7.js
module.exports = {
  version: 7,
  appVersion: "0.5.0",
  modifications: [
    "ALTER TABLE sessions ADD COLUMN IF NOT EXISTS problem TEXT;",
    "ALTER TABLE sessions ADD COLUMN IF NOT EXISTS images TEXT[];"
  ],
};


================================================
File: scripts/migrations/migrationV8.js
================================================
// src/scripts/migrations/migrationV8.js
module.exports = {
  version: 8,
  appVersion: "0.6.2",
  modifications: [
    "ALTER TABLE sessions ADD COLUMN IF NOT EXISTS messages JSONB;",
  ],
};


================================================
File: scripts/migrations/migrationV9.js
================================================
// scripts/migrations/migrationV9.js
module.exports = {
  version: 9,
  appVersion: "0.6.4",
  modifications: [
    // Step 1: Drop the user_id column if it exists (to handle failed previous attempts)
    "ALTER TABLE sessions DROP COLUMN IF EXISTS user_id;",
    // Step 2: Add the user_id column without constraints
    "ALTER TABLE sessions ADD COLUMN IF NOT EXISTS user_id UUID;",
    // Step 3: Add the foreign key constraint (allows NULL values by default)
    "ALTER TABLE sessions ADD CONSTRAINT fk_user_id FOREIGN KEY (user_id) REFERENCES auth.users(id);",
  ],
};


================================================
File: src/audio-utils.ts
================================================
type RecordAudioType = {
  (stream: MediaStream): Promise<Blob>
  stop: () => void
  currentRecorder?: MediaRecorder
}

export const recordAudio = (function (): RecordAudioType {
  const func = async function recordAudio(stream: MediaStream): Promise<Blob> {
    try {
      const mediaRecorder = new MediaRecorder(stream, {
        mimeType: "audio/webm;codecs=opus",
      })
      const audioChunks: Blob[] = []

      return new Promise((resolve, reject) => {
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunks.push(event.data)
          }
        }

        mediaRecorder.onstop = () => {
          const audioBlob = new Blob(audioChunks, { type: "audio/webm" })
          resolve(audioBlob)
        }

        mediaRecorder.onerror = () => {
          reject(new Error("MediaRecorder error occurred"))
        }

        mediaRecorder.start(1000)
        ;(func as RecordAudioType).currentRecorder = mediaRecorder
      })
    } catch (error) {
      const errorMessage =
        error instanceof Error ? error.message : "Unknown error occurred"
      throw new Error("Failed to start recording: " + errorMessage)
    }
  }

  ;(func as RecordAudioType).stop = () => {
    const recorder = (func as RecordAudioType).currentRecorder
    if (recorder && recorder.state !== "inactive") {
      recorder.stop()
    }
    delete (func as RecordAudioType).currentRecorder
  }

  return func as RecordAudioType
})()



================================================
File: src/middleware.ts
================================================
// src/middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

// Utility to get a cookie by name
const getCookie = (name: string, cookies: string): string | null => {
  const value = `; ${cookies}`;
  const parts = value.split(`; ${name}=`);
  if (parts.length === 2) return parts.pop()?.split(";").shift() || null;
  return null;
};

export async function middleware(request: NextRequest) {
  const token = getCookie("supabase-auth-token", request.headers.get("cookie") || "");
  console.log("Middleware: Token from cookie -", token);

  let user = null;
  if (token) {
    const res = await fetch(`${request.nextUrl.origin}/api/auth/user`, {
      headers: { Authorization: `Bearer ${token}` },
    });
    if (res.ok) {
      user = await res.json();
    }
    console.log("Middleware: User fetched from API -", user);
  } else {
    console.log("Middleware: No token found, user is not authenticated");
  }

  const pathname = request.nextUrl.pathname;
  console.log(`Middleware: Pathname - ${pathname}, User -`, user);

  // Redirect authenticated users from / to /chat
  if (user && pathname === "/") {
    console.log("Middleware: Authenticated user on /, redirecting to /chat");
    return NextResponse.redirect(new URL("/chat", request.url));
  }

  // Redirect unauthenticated users from protected routes to /
  if (!user && (pathname.startsWith("/chat") || pathname.startsWith("/history") || pathname.startsWith("/session"))) {
    console.log("Middleware: Unauthenticated user on protected route, redirecting to /");
    return NextResponse.redirect(new URL("/", request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: ["/", "/chat", "/history", "/session/:path*"],
};


================================================
File: src/app/globals.css
================================================
/* src/app/globals.css */
@config "../../tailwind.config.js";
@import "tailwindcss";
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 240 10% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 240 10% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 240 10% 3.9%;
    --primary: 240 5.9% 10%;
    --primary-foreground: 0 0% 98%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 4.8% 95.9%;
    --muted-foreground: 240 3.8% 46.1%;
    --accent: 240 4.8% 95.9%;
    --accent-foreground: 240 5.9% 10%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 90%;
    --input: 240 5.9% 90%;
    --ring: 240 5.9% 10%;
    --radius: 0.75rem;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
  }

  .dark {
    --background: 240 10% 3.9%;
    --foreground: 0 0% 98%;
    --card: 240 10% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 240 10% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 240 5.9% 10%;
    --secondary: 240 4.8% 95.9%;
    --secondary-foreground: 240 5.9% 10%;
    --muted: 240 3.7% 15.9%;
    --muted-foreground: 240 5% 64.9%;
    --accent: 240 3.7% 15.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 240 5.9% 26.1%;
    --input: 240 5.9% 26.1%;
    --ring: 240 4.9% 83.9%;
    --radius: 0.75rem;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}

/* Custom styles for submit button */
button[type="submit"] {
  background-color: hsl(var(--secondary)) !important;
  color: hsl(var(--secondary-foreground)) !important;
}

button[type="submit"]:hover {
  background-color: hsl(var(--muted)) !important;
}

/* Custom styles for message bubbles */
.chat-message-user {
  color: hsl(var(--foreground)) !important; /* White for user messages */
}

.chat-message-assistant {
  background-color: hsl(var(--secondary)) !important; /* Light gray for assistant messages */
  color: hsl(var(--secondary-foreground)) !important;
}

/* Improve HTML rendering within assistant messages */
.chat-message-assistant p {
  margin-bottom: 1rem; /* Add spacing between paragraphs */
  line-height: 1.5; /* Increase line spacing within paragraphs */
}

.chat-message-assistant ul {
  list-style-type: disc; /* Ensure bullet points are visible */
  margin-left: 1.5rem; /* Indent the list */
  margin-bottom: 1rem; /* Add spacing below the list */
}

.chat-message-assistant li {
  margin-bottom: 0.5rem; /* Add spacing between list items */
  line-height: 1.5; /* Increase line spacing within list items */
}

/* Style the readiness progress bar */
.chat-message-assistant .readiness-container {
  width: 100%;
  max-width: 300px; /* Limit the width for better readability */
  background-color: hsl(var(--muted)); /* Background for the progress bar */
  border-radius: var(--radius);
  overflow: hidden;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
}

.chat-message-assistant .readiness-bar {
  height: 10px; /* Height of the progress bar */
  background-color: hsl(var(--primary)); /* Color of the filled portion */
  transition: width 0.3s ease-in-out; /* Smooth transition for the bar */
}

/* Custom styles for input area */
.message-input textarea {
  background-color: hsl(var(--input)) !important;
  border-color: hsl(var(--border)) !important;
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05) !important;
  color: hsl(var(--foreground)) !important;
}

.message-input textarea::placeholder {
  color: hsl(var(--muted-foreground)) !important;
}

/* Style the icons/buttons in the input area */
.message-input .absolute.right-3.top-3 button {
  background-color: hsl(var(--secondary)) !important;
  color: hsl(var(--secondary-foreground)) !important;
  border: none !important;
}

.message-input .absolute.right-3.top-3 button:hover {
  background-color: hsl(var(--muted)) !important;
}

/* Essential animations */
@keyframes fadeIn {
  from { opacity: 0; transform: translateX(-20px); }
  to { opacity: 1; transform: translateX(0); }
}

@layer utilities {
  @keyframes typing-dot-bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
  }
  .animate-typing-dot-bounce {
    animation: typing-dot-bounce 0.6s infinite;
  }
  .animate-typing-dot-bounce:nth-child(1) { animation-delay: 0ms; }
  .animate-typing-dot-bounce:nth-child(2) { animation-delay: 90ms; }
  .animate-typing-dot-bounce:nth-child(3) { animation-delay: 180ms; }
  @keyframes accordion-down {
    from { height: 0; }
    to { height: var(--radix-accordion-content-height); }
  }
  @keyframes accordion-up {
    from { height: var(--radix-accordion-content-height); }
    to { height: 0; }
  }
  .animate-accordion-down { animation: accordion-down 0.2s ease-out; }
  .animate-accordion-up { animation: accordion-up 0.2s ease-out; }
}


================================================
File: src/app/layout.metadata.tsx
================================================
import type { Metadata } from "next";

export const metadata: Metadata = {
  title: "K12Beast - Personalized Tutoring for K12 Students",
  description: "A comprehensive learning app that helps K12 students master concepts through personalized tutoring, examples, and quizzes.",
};


================================================
File: src/app/layout.tsx
================================================
// src/app/layout.tsx
"use client";

import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { ThemeProvider } from "next-themes";
import { useState, useEffect } from "react";
import { Loader2 } from "lucide-react";
import { createClient } from "@supabase/supabase-js";
import Link from "next/link";
import { Toaster } from "@/components/ui/sonner"; // Add import

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  const [isLoggingIn, setIsLoggingIn] = useState(false);
  const [isLoggedIn, setIsLoggedIn] = useState(false);

  useEffect(() => {
    const checkUser = async () => {
      const { data: { user } } = await supabase.auth.getUser();
      setIsLoggedIn(!!user);
    };
    checkUser();
  }, []);

  const handleAuth = async () => {
    setIsLoggingIn(true);
    try {
      if (isLoggedIn) {
        await supabase.auth.signOut();
        setIsLoggedIn(false);
      } else {
        const { error } = await supabase.auth.signInWithOAuth({
          provider: "email",
          options: { redirectTo: "http://localhost:3000/chat" },
        });
        if (error) throw error;
      }
    } catch (error) {
      console.error("Auth error:", error);
      alert(isLoggedIn ? "Failed to logout. Please try again." : "Failed to initiate login. Please try again.");
    } finally {
      setIsLoggingIn(false);
      if (!isLoggedIn) {
        // Re-check user after login attempt (OAuth redirect handles session)
        const { data: { user } } = await supabase.auth.getUser();
        setIsLoggedIn(!!user);
      }
    }
  };

  return (
    <html lang="en" suppressHydrationWarning>
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased bg-background text-foreground`}
      >
        <ThemeProvider
          attribute="class"
          defaultTheme="system"
          enableSystem
          disableTransitionOnChange
        >
          <nav className="flex items-center justify-between p-4 bg-muted">
            <div className="text-lg font-bold">K12Beast</div>
            <div className="flex space-x-4">
              <Link href="/" className="hover:underline">
                Home
              </Link>
              <Link href="/chat" className="hover:underline">
                Chat
              </Link>
              <Link href="/history" className="hover:underline">
                History
              </Link>
              <button
                onClick={handleAuth}
                disabled={isLoggingIn}
                className="flex items-center px-3 py-1 rounded-md bg-primary text-primary-foreground hover:bg-primary/90 disabled:opacity-50"
              >
                {isLoggingIn ? (
                  <>
                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                    {isLoggedIn ? "Logging out..." : "Logging in..."}
                  </>
                ) : isLoggedIn ? (
                  "Logout"
                ) : (
                  "Login"
                )}
              </button>
            </div>
          </nav>
          <main className="p-4">{children}</main>
          <Toaster /> {/* Add Toaster component */}
        </ThemeProvider>
      </body>
    </html>
  );
}


================================================
File: src/app/page.tsx
================================================
// src/app/page.tsx
"use client";

import { useState, useEffect, useRef } from "react";
import { useRouter } from "next/navigation";
import supabase from "../supabase/browserClient";
import Link from "next/link";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Loader2 } from "lucide-react";

export default function Home() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [message, setMessage] = useState("");
  const [isSignUp, setIsSignUp] = useState(false);
  const [loading, setLoading] = useState(false);
  const router = useRouter();

  // Refs to access DOM input elements
  const emailInputRef = useRef<HTMLInputElement>(null);
  const passwordInputRef = useRef<HTMLInputElement>(null);

  useEffect(() => {
    // Validate the token on page load
    const validateToken = async () => {
      const token = document.cookie
        .split("; ")
        .find(row => row.startsWith("supabase-auth-token="))
        ?.split("=")[1];

      if (token) {
        const { data: { user }, error } = await supabase.auth.getUser(token);
        if (error || !user) {
          console.log("Invalid or expired token found, clearing cookie:", error?.message);
          document.cookie = "supabase-auth-token=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT; SameSite=Strict";
        } else {
          console.log("Valid token found, redirecting to /chat");
          router.push("/chat");
        }
      }
    };

    validateToken();

    // Listen for auth state changes for debugging
    const { data: { subscription } } = supabase.auth.onAuthStateChange((event, session) => {
      console.log("Auth state changed:", event, session);
      if (event === "SIGNED_IN" && session) {
        console.log("User signed in, session:", session);
      }
    });

    // Cleanup subscription on unmount
    return () => {
      subscription?.unsubscribe();
    };
  }, [router]);

  // Detect autofill by checking DOM values
  useEffect(() => {
    const checkAutofill = () => {
      if (emailInputRef.current && emailInputRef.current.value && !email) {
        console.log("Autofill detected for email:", emailInputRef.current.value);
        setEmail(emailInputRef.current.value);
      }
      if (passwordInputRef.current && passwordInputRef.current.value && !password) {
        console.log("Autofill detected for password:", passwordInputRef.current.value);
        setPassword(passwordInputRef.current.value);
      }
    };

    // Check immediately and after a short delay to catch late autofill
    checkAutofill();
    const timer = setTimeout(checkAutofill, 500);

    return () => clearTimeout(timer);
  }, []);

  // Log state changes for debugging
  useEffect(() => {
    console.log("Email state updated:", email);
    console.log("Password state updated:", password);
  }, [email, password]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setLoading(true);
    setMessage("");

    // Trim inputs to handle whitespace
    const trimmedEmail = email.trim();
    const trimmedPassword = password.trim();

    // Validate email and password
    if (!trimmedEmail || !trimmedPassword) {
      console.error("Validation failed: Email or password is empty after trimming", { email: trimmedEmail, password: trimmedPassword });
      setMessage("Please enter both email and password.");
      setLoading(false);
      return;
    }

    try {
      if (isSignUp) {
        console.log("Attempting sign-up with email:", trimmedEmail);
        const { error } = await supabase.auth.signUp({
          email: trimmedEmail,
          password: trimmedPassword,
        });
        if (error) {
          console.error("Sign-up error:", error.message);
          throw error;
        }
        console.log("Sign-up successful");
        setMessage("Sign-up successful! Check your email to confirm.");
      } else {
        console.log("Attempting login with email:", trimmedEmail);
        const { data, error } = await supabase.auth.signInWithPassword({
          email: trimmedEmail,
          password: trimmedPassword,
        });
        if (error) {
          console.error("Login error:", error.message);
          throw error;
        }
        console.log("Login successful, session data:", data);
        // Store the session token in a cookie
        document.cookie = `supabase-auth-token=${data.session.access_token}; path=/; max-age=${data.session.expires_in}; SameSite=Strict`;
        // Use client-side redirect
        router.push("/chat");
      }
    } catch (error) {
      console.error("Authentication error:", error);
      setMessage(error.message || "An error occurred. Please try again.");
      setLoading(false);
    }
  };

  // Trimmed values for button disabled logic
  const isFormValid = email.trim().length > 0 && password.trim().length > 0;

  return (
    <div className="min-h-screen bg-background flex flex-col">
      <header className="bg-card shadow-sm">
        <div className="container flex items-center justify-between py-4">
          <h1 className="text-2xl font-bold text-foreground">K12Beast</h1>
          <nav className="flex gap-4">
            <Link href="/chat" className="text-primary hover:underline">
              Chat
            </Link>
            <Link href="/history" className="text-primary hover:underline">
              History
            </Link>
          </nav>
        </div>
      </header>
      <div className="flex-1 flex items-center justify-center p-4">
        <div className="bg-card p-6 rounded-lg shadow-sm w-full max-w-md">
          <h1 className="text-2xl font-bold mb-4 text-foreground">
            {isSignUp ? "Sign Up for K12Beast" : "Login to K12Beast"}
          </h1>
          <form onSubmit={handleSubmit} className="space-y-4">
            <div>
              <Label htmlFor="email" className="block text-sm font-medium text-foreground">
                Email
              </Label>
              <Input
                type="email"
                id="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                onInput={(e) => setEmail(e.currentTarget.value)}
                ref={emailInputRef}
                className="mt-1"
                required
                disabled={loading}
              />
            </div>
            <div>
              <Label htmlFor="password" className="block text-sm font-medium text-foreground">
                Password
              </Label>
              <Input
                type="password"
                id="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                onInput={(e) => setPassword(e.currentTarget.value)}
                ref={passwordInputRef}
                className="mt-1"
                required
                disabled={loading}
              />
            </div>
            {message && <p className="text-destructive text-sm">{message}</p>}
            <Button type="submit" className="w-full" disabled={loading || !isFormValid}>
              {loading ? (
                <>
                  <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  {isSignUp ? "Signing Up..." : "Logging In..."}
                </>
              ) : (
                <>{isSignUp ? "Sign Up" : "Log In"}</>
              )}
            </Button>
          </form>
          <Button
            variant="outline"
            className="w-full mt-4"
            onClick={() => setIsSignUp(!isSignUp)}
            disabled={loading}
          >
            {isSignUp ? "Switch to Login" : "Switch to Sign Up"}
          </Button>
        </div>
      </div>
    </div>
  );
}


================================================
File: src/app/api/auth/user/route.ts
================================================
// src/app/api/auth/user/route.ts
import { NextRequest, NextResponse } from "next/server";
import supabase from "../../../../supabase/serverClient";

export async function GET(req: NextRequest) {
  try {
    // Extract the JWT token from the Authorization header
    const authHeader = req.headers.get("authorization");
    if (!authHeader || !authHeader.startsWith("Bearer ")) {
      console.log("Missing or invalid Authorization header:", authHeader, "Request URL:", req.url);
      return NextResponse.json({ error: "Missing or invalid Authorization header" }, { status: 401 });
    }

    const token = authHeader.split(" ")[1];
    console.log("Token received in /api/auth/user:", token);

    // Use the token to authenticate the user
    const { data: { user }, error } = await supabase.auth.getUser(token);

    if (error || !user) {
      console.log("Error fetching user or user not found:", error?.message || "No user", "Token:", token);
      return NextResponse.json({ error: "User not found" }, { status: 404 });
    }

    console.log("User fetched successfully:", user.id);
    return NextResponse.json(user, { status: 200 });
  } catch (error) {
    console.error("Error in /api/auth/user:", error.message, "Request URL:", req.url);
    return NextResponse.json({ error: error.message }, { status: 500 });
  }
}


================================================
File: src/app/api/examples/route.ts
================================================
// src/app/api/examples/route.ts
import { NextRequest, NextResponse } from "next/server";
import supabase from "../../../supabase/serverClient";
import { sendXAIRequest } from "../../../utils/xaiClient";
import { handleXAIError } from "../../../utils/xaiUtils";

const responseFormat = `Return a JSON object with a new example problem and its solution, related to the same topic as the original input problem. Structure: {"problem": "Example problem text", "solution": [{"title": "Step 1", "content": "Step content..."}, ...]}. Do not repeat problems from the session history or the original input problem. Do not reference images unless provided in the current request. Ensure the problem and solution steps are concise and appropriate for the student's inferred skill level.`;

const defaultResponse = {
  problem: "",
  solution: [],
};

export async function POST(req: NextRequest) {
  try {
    const { problem, images } = await req.json();
    const sessionId = req.headers.get("x-session-id") || null;

    console.log("Examples request body:", { problem, images });
    console.log("Examples session ID from header:", sessionId);

    let sessionHistory = null;
    if (sessionId) {
      const { data, error } = await supabase
        .from("sessions")
        .select("*")
        .eq("id", sessionId)
        .single();

      if (error) {
        console.error("Error fetching session from Supabase:", error.message);
      } else if (data) {
        sessionHistory = data;
        console.log("Fetched session history:", sessionHistory);
      } else {
        console.warn("No session found for ID:", sessionId);
      }
    } else {
      console.warn("No sessionId provided in request headers");
    }

    // Update the session with the user's request for an example
    if (sessionId && sessionHistory) {
      const updatedMessages = [
        ...(sessionHistory.messages || []),
        { role: "user", content: "Request Example" },
      ];
      const { error } = await supabase
        .from("sessions")
        .update({
          messages: updatedMessages,
          updated_at: new Date().toISOString(),
        })
        .eq("id", sessionId);

      if (error) {
        console.error("Error updating session with messages:", error.message);
      }
      sessionHistory.messages = updatedMessages;
    }

    const content = await sendXAIRequest({
      problem,
      images,
      responseFormat,
      defaultResponse,
      maxTokens: 1000,
      chatHistory: sessionHistory?.messages || [],
    });

    // Validate the xAI response
    if (!content.problem || !content.solution || !Array.isArray(content.solution)) {
      throw new Error("Invalid xAI response format: Expected 'problem' and 'solution' fields with 'solution' as an array");
    }

    if (sessionId) {
      const updatedExamples = [
        ...(sessionHistory?.examples || []),
        { problem: content.problem, solution: content.solution },
      ];
      // Append the assistant's response to the messages array
      const updatedMessages = [
        ...(sessionHistory?.messages || []),
        {
          role: "assistant",
          content: `<p><strong>Example:</strong> ${content.problem}</p><p><strong>Solution:</strong></p><ul>${content.solution.map((s: any) => `<li><strong>${s.title}:</strong> ${s.content}</li>`).join("")}</ul>`,
          renderAs: "html",
        },
      ];
      const { error } = await supabase
        .from("sessions")
        .update({
          examples: updatedExamples,
          messages: updatedMessages,
          updated_at: new Date().toISOString(),
        })
        .eq("id", sessionId);

      if (error) {
        console.error("Error updating session with examples:", error.message);
      } else {
        console.log("Session updated with new example:", content.problem);
      }
    }

    return NextResponse.json(content, { status: 200 });
  } catch (err) {
    return handleXAIError(err);
  }
}


================================================
File: src/app/api/quiz/route.ts
================================================
// src/app/api/quiz/route.ts
import { NextRequest, NextResponse } from "next/server";
import { sendXAIRequest } from "@/utils/xaiClient";
import { handleXAIError } from "@/utils/xaiUtils";
import supabase from "../../../supabase/serverClient";
import { v4 as uuidv4 } from "uuid";

const responseFormat = `Return a JSON object with a new quiz problem related to the same topic as the
original input problem (e.g., if the input is about heat transfer, the quiz must also be about heat
transfer). The quiz must be a multiple-choice question with exactly four distinct and plausible options
that test the student's understanding of the topic. Provide a brief context or scenario to make the
problem engaging. Do not repeat problems from the session history. Do not reference images in the
problem text. Additionally, assess the student's readiness for an end-of-semester test based on their
overall performance in the chat history, considering quiz performance (correctness, consistency, and
difficulty), engagement with lessons and examples (e.g., fewer example requests might indicate mastery),
and inferred skill level and progress (e.g., improvement over time). Provide two confidence levels: one
if the student answers this quiz correctly, and one if they answer incorrectly. Structure: {"problem":
"Quiz problem text", "answerFormat": "multiple-choice", "options": ["option1", "option2", "option3",
"option4"], "correctAnswer": "correct option", "solution": [{"title": "Step 1", "content": "Step
content in Markdown"}, ...], "difficulty": "easy|medium|hard", "encouragement": "Words of encouragement
if the last quiz was answered correctly, otherwise null", "readiness": {"confidenceIfCorrect": 0.92,
"confidenceIfIncorrect": 0.75}}. The "confidenceIfCorrect" and "confidenceIfIncorrect" fields should be
numbers between 0 and 1 indicating the AI's confidence that the student would achieve at least a 90%
success rate on an end-of-semester test without AI assistance, depending on whether they answer this quiz
correctly or incorrectly. Ensure all fields are present, especially the "solution" field with at least
two steps.`;

const defaultResponse = {
  problem: "",
  answerFormat: "multiple-choice",
  options: [],
  correctAnswer: "",
  solution: [
    { title: "Step 1", "content": "No solution provided by the model." },
    { title: "Step 2", "content": "Please try another quiz." },
  ],
  difficulty: "medium",
  encouragement: null,
  readiness: { confidenceIfCorrect: 0, confidenceIfIncorrect: 0 },
};

export async function POST(req: NextRequest) {
  try {
    const { problem, images } = await req.json();
    let sessionId = req.headers.get("x-session-id");

    console.log("Quiz request body:", { problem, images });
    console.log("Quiz session ID from header:", sessionId);

    // Fetch or create session
    let sessionHistory = null;
    if (sessionId) {
      const { data, error } = await supabase
        .from("sessions")
        .select("*")
        .eq("id", sessionId)
        .single();

      if (error) {
        console.error("Error fetching session:", error.message);
      } else if (data) {
        sessionHistory = data;
        console.log("Fetched session history for quiz:", sessionHistory);
      }
    }

    if (!sessionId || !sessionHistory) {
      sessionId = uuidv4();
      const { error } = await supabase
        .from("sessions")
        .insert({
          id: sessionId,
          messages: [{ role: "user", content: "Take a Quiz" }],
          created_at: new Date().toISOString(),
        });

      if (error) {
        console.error("Error creating session:", error.message);
        return NextResponse.json({ error: "Failed to create session" }, { status: 500 });
      }
      sessionHistory = { id: sessionId, created_at: new Date().toISOString(), messages: [{ role: "user", content: "Take a Quiz" }] };
      console.log("Created new session for quiz:", sessionId);
    } else {
      // Update the session with the user's request for a quiz
      const updatedMessages = [
        ...(sessionHistory.messages || []),
        { role: "user", content: "Take a Quiz" },
      ];
      const { error } = await supabase
        .from("sessions")
        .update({
          messages: updatedMessages,
          updated_at: new Date().toISOString(),
        })
        .eq("id", sessionId);

      if (error) {
        console.error("Error updating session with messages:", error.message);
      }
      sessionHistory.messages = updatedMessages;
    }

    const content = await sendXAIRequest({
      problem,
      images,
      responseFormat,
      defaultResponse,
      maxTokens: 1000,
      chatHistory: sessionHistory?.messages || [],
    });

    console.log("Generated quiz:", content);

    // Ensure the solution is present; if not, use the default
    if (!content.solution || content.solution.length === 0) {
      console.warn("Model did not provide a solution; using default.");
      content.solution = defaultResponse.solution;
    }

    // Store the quiz in the session without the solution (to prevent client-side access)
    const quizToStore = {
      problem: content.problem,
      answerFormat: content.answerFormat,
      options: content.options,
      correctAnswer: content.correctAnswer,
      solution: content.solution, // Store the solution server-side
      difficulty: content.difficulty,
      encouragement: content.encouragement,
      readiness: content.readiness,
    };

    const updatedQuizzes = [...(sessionHistory.quizzes || []), quizToStore];
    // Append the assistant's response to the messages array
    const updatedMessages = [
      ...(sessionHistory?.messages || []),
      {
        role: "assistant",
        content: `<strong>Quiz:</strong><br>${content.problem}<br><ul>${content.options.map((o: string) => `<li>${o}</li>`).join("")}</ul>`,
        renderAs: "html",
      },
    ];
    const { error: updateError } = await supabase
      .from("sessions")
      .update({
        quizzes: updatedQuizzes,
        messages: updatedMessages,
        updated_at: new Date().toISOString(),
      })
      .eq("id", sessionId);

    if (updateError) {
      console.error("Error updating session with quiz:", updateError.message);
    }

    // Return the quiz to the client without the solution
    return NextResponse.json(
      {
        problem: content.problem,
        answerFormat: content.answerFormat,
        options: content.options,
        correctAnswer: content.correctAnswer,
        difficulty: content.difficulty,
        encouragement: content.encouragement,
        readiness: content.readiness,
      },
      {
        status: 200,
        headers: { "x-session-id": sessionId },
      }
    );
  } catch (err) {
    return handleXAIError(err);
  }
}


================================================
File: src/app/api/session/[sessionId]/route.ts
================================================
// src/app/api/session/[sessionId]/route.ts
import { NextRequest, NextResponse } from "next/server";
import supabase from "../../../../supabase/serverClient"; // Use serverClient with service role key

export async function GET(req: NextRequest, { params }: { params: Promise<{ sessionId: string }> }) {
  try {
    const { sessionId } = await params; // Await params to access sessionId
    const { data, error } = await supabase
      .from("sessions")
      .select("*")
      .eq("id", sessionId)
      .single();

    if (error) {
      console.error("Error fetching session from Supabase:", error);
      return NextResponse.json({ error: "Failed to fetch session" }, { status: 500 });
    }

    if (!data) {
      return NextResponse.json({ error: "Session not found" }, { status: 404 });
    }

    return NextResponse.json({ session: data }, { status: 200 });
  } catch (err) {
    console.error("Unexpected error in session route:", err);
    return NextResponse.json({ error: "Unexpected error fetching session" }, { status: 500 });
  }
}


================================================
File: src/app/api/tutor/route.ts
================================================
import { v4 as uuidv4 } from 'uuid'; // Import uuid for generating session IDs
import { NextResponse } from 'next/server';
import supabase from '@/supabase/serverClient';
import { sendXAIRequest } from '@/utils/xaiClient';
import { handleApiError } from '@/utils/errorHandler';

const responseFormat = `Return a JSON object with the tutoring lesson based on the provided chat history
and original input problem or image. The response must include an evaluation of the student's problem and
proposed solution (if provided), followed by a personalized lesson. Structure: {"isK12": true, "lesson":"..."}. 
If no proposed solution is provided, the evaluation section should explain the problem's context and what the student needs to learn.
Encourage the student to request more examples and quizzes when ready. Do not quiz them yet.
If not K12-related, return {"isK12": false, "error": "Prompt must be related to K12 education"}.`;

export async function POST(request: Request) {
  try {
    const { problem, images } = await request.json();
    const sessionId = request.headers.get('x-session-id') || uuidv4(); // Use provided sessionId or generate a new one

    console.log('Creating new session with problem:', { problem, images });

    // Insert a new session with a generated ID
    const { data, error } = await supabase
      .from('sessions')
      .insert({
        id: sessionId, // Provide the ID
        lesson: null,
        examples: null,
        quizzes: null,
        performanceHistory: null,
      })
      .select()
      .single();

    if (error || !data) {
      console.error('Error creating session:', error?.message || 'No data returned');
      throw new Error(`Failed to create session: ${error?.message || 'Unknown error'}`);
    }

    const session = data;

    // Send request to xAI API for a lesson
    const lessonResponse = await sendXAIRequest({
      problem,
      images,
      responseFormat,
      defaultResponse: { isK12: true, lesson: 'No lesson generated.' },
      validateK12: true,
      chatHistory: [], // Add chat history if needed
    });

    // Check if the response is K12-related
    if (!lessonResponse.isK12) {
      throw new Error(lessonResponse.error || 'Prompt must be related to K12 education');
    }

    if (!lessonResponse.lesson) {
      throw new Error('No lesson returned from xAI API');
    }

    // Update the session with the lesson
    const { error: updateError } = await supabase
      .from('sessions')
      .update({ lesson: lessonResponse.lesson })
      .eq('id', sessionId);

    if (updateError) {
      throw new Error(`Failed to update session with lesson: ${updateError.message}`);
    }

    // Return the lesson content directly as a string (not wrapped in JSON)
    return new NextResponse(lessonResponse.lesson, {
      headers: {
        'Content-Type': 'text/plain', // Indicate that the response is plain text (HTML string)
        'x-session-id': sessionId,
      },
    });
  } catch (error) {
    return handleApiError(error, '/api/tutor');
  }
}


================================================
File: src/app/api/upload-image/route.ts
================================================
import { NextRequest, NextResponse } from "next/server";
import supabase from "../../../supabase/serverClient";

export async function POST(req: NextRequest) {
  try {
    // Parse the multipart form data
    const formData = await req.formData();
    const files = formData.getAll("files") as File[];

    if (!files || files.length === 0) {
      return NextResponse.json({ error: "No files provided" }, { status: 400 });
    }

    // Enforce limits on the server side
    const MAX_FILES = 5;
    const MAX_FILE_SIZE = 5 * 1024 * 1024; // 5MB in bytes

    // Check the number of files
    if (files.length > MAX_FILES) {
      return NextResponse.json({ error: `You can only upload a maximum of ${MAX_FILES} images` }, { status: 400 });
    }

    // Check file sizes
    const oversizedFiles = files.filter(file => file.size > MAX_FILE_SIZE);
    if (oversizedFiles.length > 0) {
      return NextResponse.json({ error: `Some files exceed the ${MAX_FILE_SIZE / (1024 * 1024)}MB size limit` }, { status: 400 });
    }

    // Upload images to Supabase Storage
    const uploadPromises = files.map(async (file) => {
      const fileName = `${Date.now()}-${file.name}`;
      const { data, error } = await supabase.storage
        .from("problems")
        .upload(fileName, file);

      if (error) {
        throw new Error(`Failed to upload image ${file.name}: ${error.message}`);
      }

      const { data: publicData } = supabase.storage
        .from("problems")
        .getPublicUrl(fileName);

      if (!publicData.publicUrl) {
        throw new Error(`Failed to get public URL for image ${file.name}`);
      }

      return { name: file.name, url: publicData.publicUrl };
    });

    const uploadedFiles = await Promise.all(uploadPromises);

    return NextResponse.json({ success: true, files: uploadedFiles }, { status: 200 });
  } catch (err) {
    console.error("Error uploading images:", err.message); // Log only the error message, not the service role key
    return NextResponse.json({ error: err.message || "Failed to upload images" }, { status: 500 });
  }
}


================================================
File: src/app/api/validate/route.ts
================================================
// src/app/api/validate/route.ts
import { NextRequest, NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

export async function POST(request: NextRequest) {
  const sessionId = request.headers.get("x-session-id");
  const { problem, answer } = await request.json();

  try {
    if (!sessionId) {
      throw new Error("Session ID is required");
    }
    if (!problem || !answer) {
      throw new Error("Problem and answer are required");
    }

    const { data: session, error: sessionError } = await supabase
      .from("sessions")
      .select("*")
      .eq("id", sessionId)
      .single();

    if (sessionError) {
      throw new Error(`Failed to fetch session: ${sessionError.message}`);
    }

    console.log("Session data:", session);
    console.log("Looking for quiz with problem:", problem);

    const quiz = session.quizzes?.find((q: any) => q.problem.trim() === problem.trim());
    if (!quiz) {
      console.error("Quiz not found in session. Available quizzes:", session.quizzes);
      throw new Error("Quiz not found in session");
    }

    console.log("Quiz data from session:", quiz);

    const isCorrect = answer === quiz.correctAnswer;
    const commentary = isCorrect
      ? "<p>Great job! You got it right!</p>"
      : `<p>Not quite. The correct answer is ${quiz.correctAnswer}.</p>`;

    // Determine the readiness confidence based on whether the answer is correct
    const readinessConfidence = isCorrect
      ? quiz.readiness.confidenceIfCorrect
      : quiz.readiness.confidenceIfIncorrect;
    const readinessPercentage = Math.round(readinessConfidence * 100);

    // Add a motivational message based on the readiness confidence
    let motivationalMessage = "";
    if (readinessPercentage >= 90) {
      motivationalMessage = "You're doing amazing! You're very likely to ace your big test!";
    } else if (readinessPercentage >= 70) {
      motivationalMessage = "Great progress! You're on track to do well on your big test. Keep practicing!";
    } else if (readinessPercentage >= 50) {
      motivationalMessage = "You're making progress! Let's keep working to boost your confidence for the big test.";
    } else {
      motivationalMessage = "Let's keep practicing! More effort will help you succeed on your big test.";
    }

    const updatedQuizzes = [
      ...session.quizzes.filter((q: any) => q.problem !== problem),
      { ...quiz, answer, isCorrect, commentary },
    ];

    // Append the feedback to the messages array, including readiness
    const updatedMessages = [
      ...(session.messages || []),
      {
        role: "assistant",
        content: `<strong>Feedback:</strong><br><strong>Your Answer:</strong> ${answer}<br>${commentary}${isCorrect ? "" : `<br><br>${quiz.solution.map((s: any) => `<strong>${s.title}:</strong> ${s.content}`).join("<br><br>")}`}<br><br><strong>Options:</strong><br><ul>${quiz.options.map((o: string) => `<li>${o}${o === answer ? " (Your answer)" : ""}${o === quiz.correctAnswer ? " (Correct answer)" : ""}</li>`).join("")}</ul><br><br><strong>Test Readiness:</strong><br><div class="readiness-container"><div class="readiness-bar" style="width: ${readinessPercentage}%"></div></div><p>${readinessPercentage}% - ${motivationalMessage}</p>`,
        renderAs: "html",
      },
    ];

    const { error: updateError } = await supabase
      .from("sessions")
      .update({
        quizzes: updatedQuizzes,
        messages: updatedMessages,
        performanceHistory: [
          ...(session.performanceHistory || []),
          { isCorrect },
        ],
        updated_at: new Date().toISOString(),
      })
      .eq("id", sessionId);

    if (updateError) {
      throw new Error(`Failed to update session: ${updateError.message}`);
    }

    const { data: updatedSession, error: fetchError } = await supabase
      .from("sessions")
      .select("*")
      .eq("id", sessionId)
      .single();

    if (fetchError) {
      throw new Error(`Failed to fetch updated session: ${fetchError.message}`);
    }

    console.log("Session updated successfully:", updatedSession);

    return NextResponse.json({
      isCorrect,
      commentary,
      solution: isCorrect ? null : quiz.solution, // Only send solution if the answer is incorrect
    });
  } catch (error) {
    console.error("Error validating quiz:", error);
    return NextResponse.json(
      { error: error.message || "Failed to validate quiz" },
      { status: 400 }
    );
  }
}


================================================
File: src/app/chat/QuizSection.tsx
================================================
// src/app/chat/QuizSection.tsx
"use client";

import { useEffect, useState } from "react";
import useAppStore from "../../store";

export default function QuizSection({ onQuizUpdate }) {
  const {
    step,
    sessionId,
    quiz,
    setStep,
    setError,
    handleQuizSubmit,
    handleValidate,
  } = useAppStore();

  const [hasFetchedQuiz, setHasFetchedQuiz] = useState(false);

  const answer = useAppStore((state) => state.quizAnswer);
  const setAnswer = (value) => useAppStore.setState({ quizAnswer: value });
  const loading = useAppStore((state) => state.loading);

  useEffect(() => {
    if (step === "quizzes" && !quiz && !hasFetchedQuiz) {
      setHasFetchedQuiz(true);
      handleQuizSubmit();
    }
  }, [step, quiz, hasFetchedQuiz, handleQuizSubmit]);

  useEffect(() => {
    if (quiz) {
      onQuizUpdate({ type: "quiz", content: quiz.problem });
    }
  }, [quiz, onQuizUpdate]);

  const handleSubmitAnswer = async () => {
    try {
      await handleValidate(answer, quiz);
      const updatedFeedback = useAppStore.getState().quizFeedback;
      if (updatedFeedback) {
        // Remove the onQuizUpdate call since the store already adds the message
        setStep("lesson"); // Return to lesson step after quiz submission
      } else {
        console.error("No feedback received after validation");
        setError("Failed to validate quiz answer. Please try again.");
      }
    } catch (err) {
      console.error("Error submitting quiz answer:", err);
      setError(err.message || "Failed to submit quiz answer. Please try again.");
    }
  };

  if (step !== "quizzes" || !quiz) return null;

  return (
    <div className="mb-4 flex flex-col items-center">
      {loading && (
        <div className="text-blue-500">Loading... Please wait.</div>
      )}
      {useAppStore.getState().error && (
        <div className="text-red-500">{useAppStore.getState().error}</div>
      )}
      {quiz.answerFormat === "multiple-choice" && quiz.options && (
        <div className="w-full max-w-md">
          {quiz.options.map((option, index) => (
            <div key={index} className="my-2 flex items-center">
              <input
                type="radio"
                id={`option-${index}`}
                name="quiz-answer"
                value={option}
                checked={answer === option}
                onChange={(e) => setAnswer(e.target.value)}
                className="mr-2"
                disabled={loading}
              />
              <label
                htmlFor={`option-${index}`}
                className={answer === option ? "text-blue-500 font-bold" : ""}
              >
                {option}
              </label>
            </div>
          ))}
        </div>
      )}
      <button
        onClick={handleSubmitAnswer}
        disabled={!answer || loading}
        className="mt-4 px-4 py-2 bg-primary text-primary-foreground rounded-md hover:bg-primary/90 disabled:opacity-50"
      >
        Submit Quiz
      </button>
    </div>
  );
}


================================================
File: src/app/chat/page.tsx
================================================
// src/app/chat/page.tsx
"use client";

import { useEffect, useState } from "react";
import Link from "next/link";
import { Share2 } from "lucide-react";
import { toast } from "sonner";
import { ChatContainer, ChatMessages, ChatForm } from "@/components/ui/chat";
import { MessageList } from "@/components/ui/message-list";
import { MessageInput } from "@/components/ui/message-input";
import { PromptSuggestions } from "@/components/ui/prompt-suggestions";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import useAppStore from "@/store";
import QuizSection from "./QuizSection";

export default function ChatPage() {
  const {
    step,
    problem,
    messages,
    images,
    imageUrls,
    quiz,
    loading,
    quizAnswer,
    quizFeedback,
    hasSubmittedProblem,
    sessionId,
    setStep,
    setProblem,
    setImages,
    handleExamplesRequest,
    handleQuizSubmit,
    handleValidate,
    handleSubmit,
    append,
    addMessage,
  } = useAppStore();

  const [isShareModalOpen, setIsShareModalOpen] = useState(false);
  const [shareableLink, setShareableLink] = useState<string | null>(null);

  useEffect(() => {
    if (step === "problem" && !hasSubmittedProblem) {
      useAppStore.getState().reset();
    }
  }, [step, hasSubmittedProblem]);

  useEffect(() => {
    console.log("ChatPage messages:", messages);
    console.log("ChatPage loading:", loading);
  }, [messages, loading]);

  useEffect(() => {
    if (sessionId) {
      const origin = window.location.origin;
      setShareableLink(`${origin}/session/${sessionId}`);
    } else {
      setShareableLink(null);
    }
  }, [sessionId]);

  const handleSuggestionAction = (action: string) => {
    switch (action) {
      case "Request Example":
        handleExamplesRequest();
        break;
      case "Take a Quiz":
        handleQuizSubmit();
        break;
      default:
        break;
    }
  };

  const handleShare = async () => {
    if (!shareableLink) {
      alert("No active session to share.");
      return;
    }

    if (navigator.share) {
      try {
        await navigator.share({
          title: "K12Beast Session",
          text: "Check out my tutoring session on K12Beast!",
          url: shareableLink,
        });
      } catch (err) {
        console.error("Error sharing:", err);
        setIsShareModalOpen(true);
      }
    } else {
      setIsShareModalOpen(true);
    }
  };

  const handleCopyLink = async () => {
    if (shareableLink) {
      try {
        await navigator.clipboard.writeText(shareableLink);
        console.log("Triggering toast.success for copy link");
        toast.success("Link copied to clipboard!");
        setIsShareModalOpen(false); // Close the modal on success
      } catch (err) {
        console.error("Error copying link:", err);
        console.log("Triggering toast.error for copy link failure");
        toast.error("Failed to copy link to clipboard.");
      }
    }
  };

  const filteredMessages = messages.map((message) => {
    if (
      message.role === "assistant" &&
      message.content.startsWith("<strong>Quiz:</strong>") &&
      step === "quizzes" &&
      !quizFeedback
    ) {
      const problemEndIndex = message.content.indexOf("<ul>");
      if (problemEndIndex !== -1) {
        return {
          ...message,
          content: message.content.substring(0, problemEndIndex),
        };
      }
    }
    return message;
  });

  return (
    <div className="h-[calc(100vh-4rem)] flex flex-col relative">
      <div className="flex-1 max-w-5xl mx-auto w-full px-4 py-6 flex flex-col">
        <ChatContainer className="flex-1">
          <ChatMessages className="flex flex-col items-start">
            <MessageList messages={filteredMessages} isTyping={loading} />
          </ChatMessages>
          {(step === "problem" && !hasSubmittedProblem) && (
            <PromptSuggestions
              className="mb-8"
              label="Try these prompts ✨"
              append={(message) => append(message, imageUrls)}
              suggestions={[
                "Explain step-by-step how to solve this math problem: if x * x + 9 = 25, what is x?",
                "Problem: Room 1 is at 18'C. Room 2 is at 22'C. Which direction will heat flow?.",
                "Problem: Simplify 3(4x + 6z). I think the answer is: 12x+19z",
              ]}
            />
          )}
          {(step === "lesson" || step === "examples") && (
            <PromptSuggestions
              className="mb-8"
              label="What would you like to do next?"
              append={(message) => handleSuggestionAction(message.content)}
              suggestions={["Request Example", "Take a Quiz"]}
            />
          )}
          {(step === "problem" && !hasSubmittedProblem) && (
            <ChatForm
              className="mt-auto"
              isPending={loading}
              handleSubmit={(e) => {
                e.preventDefault();
                handleSubmit(problem, imageUrls);
              }}
            >
              {({ files, setFiles }) => (
                <MessageInput
                  value={problem}
                  onChange={(e) => setProblem(e.target.value)}
                  allowAttachments={true}
                  files={images}
                  setFiles={(files) => setImages(files || [])}
                  isGenerating={loading}
                  placeholder="Ask k12beast AI..."
                />
              )}
            </ChatForm>
          )}
        </ChatContainer>
        {step === "quizzes" && quiz && !quizFeedback && (
          <QuizSection onQuizUpdate={() => {}} />
        )}
      </div>

      {hasSubmittedProblem && (
        <Button
          onClick={handleShare}
          className="fixed top-16 right-4 bg-primary text-primary-foreground rounded-full p-3 shadow-lg hover:bg-primary/90 z-50"
          aria-label="Share session"
        >
          <Share2 className="h-5 w-5" />
        </Button>
      )}

      <Dialog open={isShareModalOpen} onOpenChange={setIsShareModalOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Share Your Session</DialogTitle>
          </DialogHeader>
          <p>Copy this link to share your session:</p>
          <input
            type="text"
            value={shareableLink || ""}
            readOnly
            className="w-full p-2 border rounded"
          />
          <Button onClick={handleCopyLink}>
            Copy Link
          </Button>
        </DialogContent>
      </Dialog>
    </div>
  );
}


================================================
File: src/app/history/SessionItem.tsx
================================================
// src/app/history/SessionItem.tsx
"use client";

import { useState, useEffect } from "react";
import Link from "next/link";
import { Share2, Loader2 } from "lucide-react";
import { toast } from "sonner";
import { Dialog, DialogContent, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import supabase from "@/supabase/browserClient";

interface SessionItemProps {
  sessionId: string;
}

export default function SessionItem({ sessionId }: SessionItemProps) {
  const [session, setSession] = useState<any>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isShareModalOpen, setIsShareModalOpen] = useState(false);
  const shareableLink = `${window.location.origin}/session/${sessionId}`;

  useEffect(() => {
    const fetchSession = async () => {
      setLoading(true);
      setError(null);
      try {
        const { data, error } = await supabase
          .from("sessions")
          .select("id, created_at, completed, messages")
          .eq("id", sessionId)
          .single();

        if (error) throw new Error(error.message);
        setSession(data);
      } catch (err: any) {
        console.error("Error fetching session:", err);
        setError("Failed to load session. Please try again.");
      } finally {
        setLoading(false);
      }
    };

    fetchSession();
  }, [sessionId]);

  const handleShare = async () => {
    if (navigator.share) {
      try {
        await navigator.share({
          title: "K12Beast Session",
          text: "Check out my tutoring session on K12Beast!",
          url: shareableLink,
        });
      } catch (err) {
        console.error("Error sharing:", err);
        setIsShareModalOpen(true);
      }
    } else {
      setIsShareModalOpen(true);
    }
  };

  const handleCopyLink = async () => {
    try {
      await navigator.clipboard.writeText(shareableLink);
      console.log("Triggering toast.success for copy link");
      toast.success("Link copied to clipboard!");
      setIsShareModalOpen(false);
    } catch (err) {
      console.error("Error copying link:", err);
      console.log("Triggering toast.error for copy link failure");
      toast.error("Failed to copy link to clipboard.");
    }
  };

  if (loading) {
    return (
      <div className="flex items-center p-4 rounded-lg border bg-card">
        <Loader2 className="h-4 w-4 animate-spin mr-2" />
        <p>Loading session...</p>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-4 rounded-lg border bg-card text-destructive">
        <p>{error}</p>
      </div>
    );
  }

  if (!session) {
    return (
      <div className="p-4 rounded-lg border bg-card text-muted-foreground">
        <p>Session not found.</p>
      </div>
    );
  }

  const firstUserMessage =
    session.messages?.find((msg: any) => msg.role === "user")?.content || "Image-based Problem";

  return (
    <>
      <div className="flex items-center justify-between p-4 rounded-lg border bg-card hover:bg-muted transition">
        <Link href={`/session/${session.id}`} className="flex-1">
          <h2 className="text-lg font-semibold">{firstUserMessage}</h2>
          <p className="text-sm text-muted-foreground">
            {new Date(session.created_at).toLocaleString()}
          </p>
          <p className="text-sm mt-2">
            {session.completed ? "Completed" : "In Progress"}
          </p>
        </Link>
        <Button
          onClick={handleShare}
          variant="outline"
          size="sm"
          aria-label="Share session"
        >
          <Share2 className="h-4 w-4" />
        </Button>
      </div>

      <Dialog open={isShareModalOpen} onOpenChange={setIsShareModalOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Share Your Session</DialogTitle>
          </DialogHeader>
          <p>Copy this link to share your session:</p>
          <input
            type="text"
            value={shareableLink}
            readOnly
            className="w-full p-2 border rounded"
          />
          <Button onClick={handleCopyLink}>Copy Link</Button>
        </DialogContent>
      </Dialog>
    </>
  );
}


================================================
File: src/app/history/page.tsx
================================================
// src/app/history/page.tsx
import { createClient } from "@supabase/supabase-js";
import Link from "next/link";
import SessionItem from "./SessionItem";

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!
);

async function fetchSessions() {
  const { data, error } = await supabase
    .from("sessions")
    .select("id") // Fetch only the id
    .order("created_at", { ascending: false });
  if (error) throw new Error(error.message);
  return data;
}

export default async function HistoryPage() {
  const sessions = await fetchSessions();

  return (
    <div className="container">
      <h1 className="text-2xl font-bold mb-6">Session History</h1>
      {sessions.length === 0 ? (
        <p className="text-muted-foreground">
          No sessions found. Start a new session in the{" "}
          <Link href="/chat" className="text-primary underline">
            Chat
          </Link>{" "}
          page.
        </p>
      ) : (
        <div className="space-y-4">
          {sessions.map((session: any) => (
            // key is for React list rendering, sessionId is for SessionItem to fetch data
            <SessionItem key={session.id} sessionId={session.id} />
          ))}
        </div>
      )}
    </div>
  );
}


================================================
File: src/app/session/[sessionId]/page.tsx
================================================
// src/app/session/[sessionId]/page.tsx
import { ChatContainer, ChatMessages } from "@/components/ui/chat";
import { MessageList } from "@/components/ui/message-list";

async function fetchSession(sessionId: string) {
  const res = await fetch(`http://localhost:3000/api/session/${sessionId}`, {
    method: "GET",
    headers: {
      "Content-Type": "application/json",
    },
    cache: "no-store", // Ensure fresh data
  });

  if (!res.ok) {
    const errorData = await res.json();
    throw new Error(errorData.error || "Failed to fetch session");
  }

  const data = await res.json();
  return data.session; // The API route returns { session: data }
}

export default async function SessionDetailPage({
  params: paramsPromise,
}: {
  params: Promise<{ sessionId: string }>;
}) {
  const params = await paramsPromise; // Await params to access sessionId
  const session = await fetchSession(params.sessionId);

  return (
    <div className="container">
      <h1 className="text-2xl font-bold mb-6">Session Details</h1>
      <div className="space-y-4">
        <p><strong>Lesson:</strong> {session.lesson || "No lesson provided"}</p>
        <ChatContainer className="flex-1">
          <ChatMessages className="flex flex-col items-start">
            <MessageList messages={session.messages || []} />
          </ChatMessages>
        </ChatContainer>
      </div>
    </div>
  );
}


================================================
File: src/components/lib/audio-utils.ts
================================================
export async function recordAudio(): Promise<{ start: () => void; stop: () => Promise<Blob> }> {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);
      const audioChunks: Blob[] = [];
  
      mediaRecorder.ondataavailable = (event) => {
        if (event.data.size > 0) {
          audioChunks.push(event.data);
        }
      };
  
      return {
        start: () => {
          audioChunks.length = 0; // Clear previous chunks
          mediaRecorder.start();
        },
        stop: () => {
          return new Promise((resolve) => {
            mediaRecorder.onstop = () => {
              const audioBlob = new Blob(audioChunks, { type: "audio/webm" });
              stream.getTracks().forEach((track) => track.stop()); // Stop the stream
              resolve(audioBlob);
            };
            mediaRecorder.stop();
          });
        },
      };
    } catch (error) {
      throw new Error("Failed to access microphone: " + error.message);
    }
  }


================================================
File: src/components/ui/audio-visualizer.tsx
================================================
"use client"

import { useEffect, useRef } from "react"

// Configuration constants for the audio analyzer
const AUDIO_CONFIG = {
  FFT_SIZE: 512,
  SMOOTHING: 0.8,
  MIN_BAR_HEIGHT: 2,
  MIN_BAR_WIDTH: 2,
  BAR_SPACING: 1,
  COLOR: {
    MIN_INTENSITY: 100, // Minimum gray value (darker)
    MAX_INTENSITY: 255, // Maximum gray value (brighter)
    INTENSITY_RANGE: 155, // MAX_INTENSITY - MIN_INTENSITY
  },
} as const

interface AudioVisualizerProps {
  stream: MediaStream | null
  isRecording: boolean
  onClick: () => void
}

export function AudioVisualizer({
  stream,
  isRecording,
  onClick,
}: AudioVisualizerProps) {
  // Refs for managing audio context and animation
  const canvasRef = useRef<HTMLCanvasElement>(null)
  const audioContextRef = useRef<AudioContext | null>(null)
  const analyserRef = useRef<AnalyserNode | null>(null)
  const animationFrameRef = useRef<number>()
  const containerRef = useRef<HTMLDivElement>(null)

  // Cleanup function to stop visualization and close audio context
  const cleanup = () => {
    if (animationFrameRef.current) {
      cancelAnimationFrame(animationFrameRef.current)
    }
    if (audioContextRef.current) {
      audioContextRef.current.close()
    }
  }

  // Cleanup on unmount
  useEffect(() => {
    return cleanup
  }, [])

  // Start or stop visualization based on recording state
  useEffect(() => {
    if (stream && isRecording) {
      startVisualization()
    } else {
      cleanup()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [stream, isRecording])

  // Handle window resize
  useEffect(() => {
    const handleResize = () => {
      if (canvasRef.current && containerRef.current) {
        const container = containerRef.current
        const canvas = canvasRef.current
        const dpr = window.devicePixelRatio || 1

        // Set canvas size based on container and device pixel ratio
        const rect = container.getBoundingClientRect()
        // Account for the 2px total margin (1px on each side)
        canvas.width = (rect.width - 2) * dpr
        canvas.height = (rect.height - 2) * dpr

        // Scale canvas CSS size to match container minus margins
        canvas.style.width = `${rect.width - 2}px`
        canvas.style.height = `${rect.height - 2}px`
      }
    }

    window.addEventListener("resize", handleResize)
    // Initial setup
    handleResize()

    return () => window.removeEventListener("resize", handleResize)
  }, [])

  // Initialize audio context and start visualization
  const startVisualization = async () => {
    try {
      const audioContext = new AudioContext()
      audioContextRef.current = audioContext

      const analyser = audioContext.createAnalyser()
      analyser.fftSize = AUDIO_CONFIG.FFT_SIZE
      analyser.smoothingTimeConstant = AUDIO_CONFIG.SMOOTHING
      analyserRef.current = analyser

      const source = audioContext.createMediaStreamSource(stream!)
      source.connect(analyser)

      draw()
    } catch (error) {
      console.error("Error starting visualization:", error)
    }
  }

  // Calculate the color intensity based on bar height
  const getBarColor = (normalizedHeight: number) => {
    const intensity =
      Math.floor(normalizedHeight * AUDIO_CONFIG.COLOR.INTENSITY_RANGE) +
      AUDIO_CONFIG.COLOR.MIN_INTENSITY
    return `rgb(${intensity}, ${intensity}, ${intensity})`
  }

  // Draw a single bar of the visualizer
  const drawBar = (
    ctx: CanvasRenderingContext2D,
    x: number,
    centerY: number,
    width: number,
    height: number,
    color: string
  ) => {
    ctx.fillStyle = color
    // Draw upper bar (above center)
    ctx.fillRect(x, centerY - height, width, height)
    // Draw lower bar (below center)
    ctx.fillRect(x, centerY, width, height)
  }

  // Main drawing function
  const draw = () => {
    if (!isRecording) return

    const canvas = canvasRef.current
    const ctx = canvas?.getContext("2d")
    if (!canvas || !ctx || !analyserRef.current) return

    const dpr = window.devicePixelRatio || 1
    ctx.scale(dpr, dpr)

    const analyser = analyserRef.current
    const bufferLength = analyser.frequencyBinCount
    const frequencyData = new Uint8Array(bufferLength)

    const drawFrame = () => {
      animationFrameRef.current = requestAnimationFrame(drawFrame)

      // Get current frequency data
      analyser.getByteFrequencyData(frequencyData)

      // Clear canvas - use CSS pixels for clearing
      ctx.clearRect(0, 0, canvas.width / dpr, canvas.height / dpr)

      // Calculate dimensions in CSS pixels
      const barWidth = Math.max(
        AUDIO_CONFIG.MIN_BAR_WIDTH,
        canvas.width / dpr / bufferLength - AUDIO_CONFIG.BAR_SPACING
      )
      const centerY = canvas.height / dpr / 2
      let x = 0

      // Draw each frequency bar
      for (let i = 0; i < bufferLength; i++) {
        const normalizedHeight = frequencyData[i] / 255 // Convert to 0-1 range
        const barHeight = Math.max(
          AUDIO_CONFIG.MIN_BAR_HEIGHT,
          normalizedHeight * centerY
        )

        drawBar(
          ctx,
          x,
          centerY,
          barWidth,
          barHeight,
          getBarColor(normalizedHeight)
        )

        x += barWidth + AUDIO_CONFIG.BAR_SPACING
      }
    }

    drawFrame()
  }

  return (
    <div
      ref={containerRef}
      className="h-full w-full cursor-pointer rounded-lg bg-background/80 backdrop-blur"
      onClick={onClick}
    >
      <canvas ref={canvasRef} className="h-full w-full" />
    </div>
  )
}



================================================
File: src/components/ui/button.tsx
================================================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }



================================================
File: src/components/ui/card.tsx
================================================
import * as React from "react"

import { cn } from "@/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn(
        "@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6",
        className
      )}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardAction({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-action"
      className={cn(
        "col-start-2 row-span-2 row-start-1 self-start justify-self-end",
        className
      )}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6 [.border-t]:pt-6", className)}
      {...props}
    />
  )
}

export {
  Card,
  CardHeader,
  CardFooter,
  CardTitle,
  CardAction,
  CardDescription,
  CardContent,
}



================================================
File: src/components/ui/chat-message.tsx
================================================
// src/components/ui/chat-message.tsx
"use client";

import React, { useMemo } from "react";
import { cva, type VariantProps } from "class-variance-authority";
import { motion } from "framer-motion";
import { Ban, ChevronRight, Code2, Loader2, Terminal } from "lucide-react";
import DOMPurify from "dompurify";

import { cn } from "@/utils";
import {
  Collapsible,
  CollapsibleContent,
  CollapsibleTrigger,
} from "@/components/ui/collapsible";
import { FilePreview } from "@/components/ui/file-preview";
import { MarkdownRenderer } from "@/components/ui/markdown-renderer";

const chatBubbleVariants = cva(
  "group/message relative break-words rounded-lg p-3 text-sm sm:max-w-[70%]",
  {
    variants: {
      isUser: {
        true: "bg-primary text-primary-foreground",
        false: "bg-muted text-foreground",
      },
      animation: {
        none: "",
        slide: "duration-300 animate-in fade-in-0",
        scale: "duration-300 animate-in fade-in-0 zoom-in-75",
        fade: "duration-500 animate-in fade-in-0",
      },
    },
    compoundVariants: [
      {
        isUser: true,
        animation: "slide",
        class: "slide-in-from-right",
      },
      {
        isUser: false,
        animation: "slide",
        class: "slide-in-from-left",
      },
      {
        isUser: true,
        animation: "scale",
        class: "origin-bottom-right",
      },
      {
        isUser: false,
        animation: "scale",
        class: "origin-bottom-left",
      },
    ],
  }
);

type Animation = VariantProps<typeof chatBubbleVariants>["animation"];

interface Attachment {
  name?: string;
  contentType?: string;
  url: string;
}

interface PartialToolCall {
  state: "partial-call";
  toolName: string;
}

interface ToolCall {
  state: "call";
  toolName: string;
}

interface ToolResult {
  state: "result";
  toolName: string;
  result: {
    __cancelled?: boolean;
    [key: string]: any;
  };
}

type ToolInvocation = PartialToolCall | ToolCall | ToolResult;

interface ReasoningPart {
  type: "reasoning";
  reasoning: string;
}

interface ToolInvocationPart {
  type: "tool-invocation";
  toolInvocation: ToolInvocation;
}

interface TextPart {
  type: "text";
  text: string;
}

// For compatibility with AI SDK types, not used
interface SourcePart {
  type: "source";
}

type MessagePart = TextPart | ReasoningPart | ToolInvocationPart | SourcePart;

export interface Message {
  id: string;
  role: "user" | "assistant" | (string & {});
  content: string;
  createdAt?: Date;
  experimental_attachments?: Attachment[];
  toolInvocations?: ToolInvocation[];
  parts?: MessagePart[];
  renderAs?: "markdown" | "html"; // New attribute to control rendering
}

export interface ChatMessageProps extends Message {
  showTimeStamp?: boolean;
  animation?: Animation;
  actions?: React.ReactNode;
}

export const ChatMessage: React.FC<ChatMessageProps> = ({
  role,
  content,
  createdAt,
  showTimeStamp = false,
  animation = "scale",
  actions,
  experimental_attachments,
  toolInvocations,
  parts,
  renderAs = "markdown", // Default to markdown rendering
}) => {
  const files = useMemo(() => {
    return experimental_attachments?.map((attachment) => {
      const dataArray = dataUrlToUint8Array(attachment.url);
      const file = new File([dataArray], attachment.name ?? "Unknown");
      return file;
    });
  }, [experimental_attachments]);

  const isUser = role === "user";

  const formattedTime = createdAt?.toLocaleTimeString("en-US", {
    hour: "2-digit",
    minute: "2-digit",
  });

  const sanitizeContent = (html: string) => {
    if (typeof DOMPurify.sanitize !== "function") {
      console.error("DOMPurify.sanitize is not a function. Falling back to plain text.");
      return html; // Fallback to plain text if sanitization fails
    }
    return DOMPurify.sanitize(html);
  };

  if (isUser) {
    return (
      <div
        className={cn("flex flex-col", isUser ? "items-end" : "items-start")}
      >
        {files ? (
          <div className="mb-1 flex flex-wrap gap-2">
            {files.map((file, index) => {
              return <FilePreview file={file} key={index} />;
            })}
          </div>
        ) : null}

        <div className={cn(chatBubbleVariants({ isUser, animation }))}>
          <MarkdownRenderer>{content}</MarkdownRenderer>
        </div>

        {showTimeStamp && createdAt ? (
          <time
            dateTime={createdAt.toISOString()}
            className={cn(
              "mt-1 block px-1 text-xs opacity-50",
              animation !== "none" && "duration-500 animate-in fade-in-0"
            )}
          >
            {formattedTime}
          </time>
        ) : null}
      </div>
    );
  }

  if (parts && parts.length > 0) {
    return parts.map((part, index) => {
      if (part.type === "text") {
        return (
          <div
            className={cn(
              "flex flex-col",
              isUser ? "items-end" : "items-start"
            )}
            key={`text-${index}`}
          >
            <div className={cn(chatBubbleVariants({ isUser, animation }))}>
              <MarkdownRenderer>{part.text}</MarkdownRenderer>
              {actions ? (
                <div className="absolute -bottom-4 right-2 flex space-x-1 rounded-lg border bg-background p-1 text-foreground opacity-0 transition-opacity group-hover/message:opacity-100">
                  {actions}
                </div>
              ) : null}
            </div>

            {showTimeStamp && createdAt ? (
              <time
                dateTime={createdAt.toISOString()}
                className={cn(
                  "mt-1 block px-1 text-xs opacity-50",
                  animation !== "none" && "duration-500 animate-in fade-in-0"
                )}
              >
                {formattedTime}
              </time>
            ) : null}
          </div>
        );
      } else if (part.type === "reasoning") {
        return <ReasoningBlock key={`reasoning-${index}`} part={part} />;
      } else if (part.type === "tool-invocation") {
        return (
          <ToolCall
            key={`tool-${index}`}
            toolInvocations={[part.toolInvocation]}
          />
        );
      }
      return null;
    });
  }

  if (toolInvocations && toolInvocations.length > 0) {
    return <ToolCall toolInvocations={toolInvocations} />;
  }

  return (
    <div className={cn("flex flex-col", isUser ? "items-end" : "items-start")}>
      <div className={cn(chatBubbleVariants({ isUser, animation }))}>
        {renderAs === "html" ? (
          // Render as safe HTML using DOMPurify
          <div dangerouslySetInnerHTML={{ __html: sanitizeContent(content) }} />
        ) : (
          // Render as Markdown using MarkdownRenderer
          <MarkdownRenderer>{content}</MarkdownRenderer>
        )}
        {actions ? (
          <div className="absolute -bottom-4 right-2 flex space-x-1 rounded-lg border bg-background p-1 text-foreground opacity-0 transition-opacity group-hover/message:opacity-100">
            {actions}
          </div>
        ) : null}
      </div>

      {showTimeStamp && createdAt ? (
        <time
          dateTime={createdAt.toISOString()}
          className={cn(
            "mt-1 block px-1 text-xs opacity-50",
            animation !== "none" && "duration-500 animate-in fade-in-0"
          )}
        >
          {formattedTime}
        </time>
      ) : null}
    </div>
  );
}

function dataUrlToUint8Array(data: string) {
  const base64 = data.split(",")[1];
  const buf = Buffer.from(base64, "base64");
  return new Uint8Array(buf);
}

const ReasoningBlock = ({ part }: { part: ReasoningPart }) => {
  const [isOpen, setIsOpen] = useState(false);

  return (
    <div className="mb-2 flex flex-col items-start sm:max-w-[70%]">
      <Collapsible
        open={isOpen}
        onOpenChange={setIsOpen}
        className="group w-full overflow-hidden rounded-lg border bg-muted/50"
      >
        <div className="flex items-center p-2">
          <CollapsibleTrigger asChild>
            <button className="flex items-center gap-2 text-sm text-muted-foreground hover:text-foreground">
              <ChevronRight className="h-4 w-4 transition-transform group-data-[state=open]:rotate-90" />
              <span>Thinking</span>
            </button>
          </CollapsibleTrigger>
        </div>
        <CollapsibleContent forceMount>
          <motion.div
            initial={false}
            animate={isOpen ? "open" : "closed"}
            variants={{
              open: { height: "auto", opacity: 1 },
              closed: { height: 0, opacity: 0 },
            }}
            transition={{ duration: 0.3, ease: [0.04, 0.62, 0.23, 0.98] }}
            className="border-t"
          >
            <div className="p-2">
              <div className="whitespace-pre-wrap text-xs">
                {part.reasoning}
              </div>
            </div>
          </motion.div>
        </CollapsibleContent>
      </Collapsible>
    </div>
  );
};

function ToolCall({
  toolInvocations,
}: Pick<ChatMessageProps, "toolInvocations">) {
  if (!toolInvocations?.length) return null;

  return (
    <div className="flex flex-col items-start gap-2">
      {toolInvocations.map((invocation, index) => {
        const isCancelled =
          invocation.state === "result" &&
          invocation.result.__cancelled === true;

        if (isCancelled) {
          return (
            <div
              key={index}
              className="flex items-center gap-2 rounded-lg border bg-muted/50 px-3 py-2 text-sm text-muted-foreground"
            >
              <Ban className="h-4 w-4" />
              <span>
                Cancelled{" "}
                <span className="font-mono">
                  {"`"}
                  {invocation.toolName}
                  {"`"}
                </span>
              </span>
            </div>
          );
        }

        switch (invocation.state) {
          case "partial-call":
          case "call":
            return (
              <div
                key={index}
                className="flex items-center gap-2 rounded-lg border bg-muted/50 px-3 py-2 text-sm text-muted-foreground"
              >
                <Terminal className="h-4 w-4" />
                <span>
                  Calling{" "}
                  <span className="font-mono">
                    {"`"}
                    {invocation.toolName}
                    {"`"}
                  </span>
                  ...
                </span>
                <Loader2 className="h-3 w-3 animate-spin" />
              </div>
            );
          case "result":
            return (
              <div
                key={index}
                className="flex flex-col gap-1.5 rounded-lg border bg-muted/50 px-3 py-2 text-sm"
              >
                <div className="flex items-center gap-2 text-muted-foreground">
                  <Code2 className="h-4 w-4" />
                  <span>
                    Result from{" "}
                    <span className="font-mono">
                      {"`"}
                      {invocation.toolName}
                      {"`"}
                    </span>
                  </span>
                </div>
                <pre className="overflow-x-auto whitespace-pre-wrap text-foreground">
                  {JSON.stringify(invocation.result, null, 2)}
                </pre>
              </div>
            );
          default:
            return null;
        }
      })}
    </div>
  );
}


================================================
File: src/components/ui/chat.tsx
================================================
"use client"

import {
  forwardRef,
  useCallback,
  useRef,
  useState,
  type ReactElement,
} from "react"
import { ArrowDown, ThumbsDown, ThumbsUp } from "lucide-react"

import { cn } from "@/utils"
import { useAutoScroll } from "@/hooks/use-auto-scroll"
import { Button } from "@/components/ui/button"
import { type Message } from "@/components/ui/chat-message"
import { CopyButton } from "@/components/ui/copy-button"
import { MessageInput } from "@/components/ui/message-input"
import { MessageList } from "@/components/ui/message-list"
import { PromptSuggestions } from "@/components/ui/prompt-suggestions"

interface ChatPropsBase {
  handleSubmit: (
    event?: { preventDefault?: () => void },
    options?: { experimental_attachments?: FileList }
  ) => void
  messages: Array<Message>
  input: string
  className?: string
  handleInputChange: React.ChangeEventHandler<HTMLTextAreaElement>
  isGenerating: boolean
  stop?: () => void
  onRateResponse?: (
    messageId: string,
    rating: "thumbs-up" | "thumbs-down"
  ) => void
  setMessages?: (messages: any[]) => void
  transcribeAudio?: (blob: Blob) => Promise<string>
}

interface ChatPropsWithoutSuggestions extends ChatPropsBase {
  append?: never
  suggestions?: never
}

interface ChatPropsWithSuggestions extends ChatPropsBase {
  append: (message: { role: "user"; content: string }) => void
  suggestions: string[]
}

type ChatProps = ChatPropsWithoutSuggestions | ChatPropsWithSuggestions

export function Chat({
  messages,
  handleSubmit,
  input,
  handleInputChange,
  stop,
  isGenerating,
  append,
  suggestions,
  className,
  onRateResponse,
  setMessages,
  transcribeAudio,
}: ChatProps) {
  const lastMessage = messages.at(-1)
  const isEmpty = messages.length === 0
  const isTyping = lastMessage?.role === "user"

  const messagesRef = useRef(messages)
  messagesRef.current = messages

  // Enhanced stop function that marks pending tool calls as cancelled
  const handleStop = useCallback(() => {
    stop?.()

    if (!setMessages) return

    const latestMessages = [...messagesRef.current]
    const lastAssistantMessage = latestMessages.findLast(
      (m) => m.role === "assistant"
    )

    if (!lastAssistantMessage) return

    let needsUpdate = false
    let updatedMessage = { ...lastAssistantMessage }

    if (lastAssistantMessage.toolInvocations) {
      const updatedToolInvocations = lastAssistantMessage.toolInvocations.map(
        (toolInvocation) => {
          if (toolInvocation.state === "call") {
            needsUpdate = true
            return {
              ...toolInvocation,
              state: "result",
              result: {
                content: "Tool execution was cancelled",
                __cancelled: true, // Special marker to indicate cancellation
              },
            } as const
          }
          return toolInvocation
        }
      )

      if (needsUpdate) {
        updatedMessage = {
          ...updatedMessage,
          toolInvocations: updatedToolInvocations,
        }
      }
    }

    if (lastAssistantMessage.parts && lastAssistantMessage.parts.length > 0) {
      const updatedParts = lastAssistantMessage.parts.map((part: any) => {
        if (
          part.type === "tool-invocation" &&
          part.toolInvocation &&
          part.toolInvocation.state === "call"
        ) {
          needsUpdate = true
          return {
            ...part,
            toolInvocation: {
              ...part.toolInvocation,
              state: "result",
              result: {
                content: "Tool execution was cancelled",
                __cancelled: true,
              },
            },
          }
        }
        return part
      })

      if (needsUpdate) {
        updatedMessage = {
          ...updatedMessage,
          parts: updatedParts,
        }
      }
    }

    if (needsUpdate) {
      const messageIndex = latestMessages.findIndex(
        (m) => m.id === lastAssistantMessage.id
      )
      if (messageIndex !== -1) {
        latestMessages[messageIndex] = updatedMessage
        setMessages(latestMessages)
      }
    }
  }, [stop, setMessages, messagesRef])

  const messageOptions = useCallback(
    (message: Message) => ({
      actions: onRateResponse ? (
        <>
          <div className="border-r pr-1">
            <CopyButton
              content={message.content}
              copyMessage="Copied response to clipboard!"
            />
          </div>
          <Button
            size="icon"
            variant="ghost"
            className="h-6 w-6"
            onClick={() => onRateResponse(message.id, "thumbs-up")}
          >
            <ThumbsUp className="h-4 w-4" />
          </Button>
          <Button
            size="icon"
            variant="ghost"
            className="h-6 w-6"
            onClick={() => onRateResponse(message.id, "thumbs-down")}
          >
            <ThumbsDown className="h-4 w-4" />
          </Button>
        </>
      ) : (
        <CopyButton
          content={message.content}
          copyMessage="Copied response to clipboard!"
        />
      ),
    }),
    [onRateResponse]
  )

  return (
    <ChatContainer className={className}>
      {isEmpty && append && suggestions ? (
        <PromptSuggestions
          label="Try these prompts ✨"
          append={append}
          suggestions={suggestions}
        />
      ) : null}

      {messages.length > 0 ? (
        <ChatMessages messages={messages}>
          <MessageList
            messages={messages}
            isTyping={isTyping}
            messageOptions={messageOptions}
          />
        </ChatMessages>
      ) : null}

      <ChatForm
        className="mt-auto"
        isPending={isGenerating || isTyping}
        handleSubmit={handleSubmit}
      >
        {({ files, setFiles }) => (
          <MessageInput
            value={input}
            onChange={handleInputChange}
            allowAttachments
            files={files}
            setFiles={setFiles}
            stop={handleStop}
            isGenerating={isGenerating}
            transcribeAudio={transcribeAudio}
          />
        )}
      </ChatForm>
    </ChatContainer>
  )
}
Chat.displayName = "Chat"

export function ChatMessages({
  messages,
  children,
}: React.PropsWithChildren<{
  messages: Message[]
}>) {
  const {
    containerRef,
    scrollToBottom,
    handleScroll,
    shouldAutoScroll,
    handleTouchStart,
  } = useAutoScroll([messages])

  return (
    <div
      className="grid grid-cols-1 overflow-y-auto pb-4"
      ref={containerRef}
      onScroll={handleScroll}
      onTouchStart={handleTouchStart}
    >
      <div className="max-w-full [grid-column:1/1] [grid-row:1/1]">
        {children}
      </div>

      {!shouldAutoScroll && (
        <div className="pointer-events-none flex flex-1 items-end justify-end [grid-column:1/1] [grid-row:1/1]">
          <div className="sticky bottom-0 left-0 flex w-full justify-end">
            <Button
              onClick={scrollToBottom}
              className="pointer-events-auto h-8 w-8 rounded-full ease-in-out animate-in fade-in-0 slide-in-from-bottom-1"
              size="icon"
              variant="ghost"
            >
              <ArrowDown className="h-4 w-4" />
            </Button>
          </div>
        </div>
      )}
    </div>
  )
}

export const ChatContainer = forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      className={cn("grid max-h-full w-full grid-rows-[1fr_auto]", className)}
      {...props}
    />
  )
})
ChatContainer.displayName = "ChatContainer"

interface ChatFormProps {
  className?: string
  isPending: boolean
  handleSubmit: (
    event?: { preventDefault?: () => void },
    options?: { experimental_attachments?: FileList }
  ) => void
  children: (props: {
    files: File[] | null
    setFiles: React.Dispatch<React.SetStateAction<File[] | null>>
  }) => ReactElement
}

export const ChatForm = forwardRef<HTMLFormElement, ChatFormProps>(
  ({ children, handleSubmit, isPending, className }, ref) => {
    const [files, setFiles] = useState<File[] | null>(null)

    const onSubmit = (event: React.FormEvent) => {
      if (!files) {
        handleSubmit(event)
        return
      }

      const fileList = createFileList(files)
      handleSubmit(event, { experimental_attachments: fileList })
      setFiles(null)
    }

    return (
      <form ref={ref} onSubmit={onSubmit} className={className}>
        {children({ files, setFiles })}
      </form>
    )
  }
)
ChatForm.displayName = "ChatForm"

function createFileList(files: File[] | FileList): FileList {
  const dataTransfer = new DataTransfer()
  for (const file of Array.from(files)) {
    dataTransfer.items.add(file)
  }
  return dataTransfer.files
}



================================================
File: src/components/ui/collapsible.tsx
================================================
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

function Collapsible({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.Root>) {
  return <CollapsiblePrimitive.Root data-slot="collapsible" {...props} />
}

function CollapsibleTrigger({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleTrigger>) {
  return (
    <CollapsiblePrimitive.CollapsibleTrigger
      data-slot="collapsible-trigger"
      {...props}
    />
  )
}

function CollapsibleContent({
  ...props
}: React.ComponentProps<typeof CollapsiblePrimitive.CollapsibleContent>) {
  return (
    <CollapsiblePrimitive.CollapsibleContent
      data-slot="collapsible-content"
      {...props}
    />
  )
}

export { Collapsible, CollapsibleTrigger, CollapsibleContent }



================================================
File: src/components/ui/copy-button.tsx
================================================
"use client"

import { Check, Copy } from "lucide-react"

import { cn } from "@/utils"
import { useCopyToClipboard } from "@/hooks/use-copy-to-clipboard"
import { Button } from "@/components/ui/button"

type CopyButtonProps = {
  content: string
  copyMessage?: string
}

export function CopyButton({ content, copyMessage }: CopyButtonProps) {
  const { isCopied, handleCopy } = useCopyToClipboard({
    text: content,
    copyMessage,
  })

  return (
    <Button
      variant="ghost"
      size="icon"
      className="relative h-6 w-6"
      aria-label="Copy to clipboard"
      onClick={handleCopy}
    >
      <div className="absolute inset-0 flex items-center justify-center">
        <Check
          className={cn(
            "h-4 w-4 transition-transform ease-in-out",
            isCopied ? "scale-100" : "scale-0"
          )}
        />
      </div>
      <Copy
        className={cn(
          "h-4 w-4 transition-transform ease-in-out",
          isCopied ? "scale-0" : "scale-100"
        )}
      />
    </Button>
  )
}



================================================
File: src/components/ui/dialog.tsx
================================================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}



================================================
File: src/components/ui/file-preview.tsx
================================================
"use client"

import React, { useEffect } from "react"
import { motion } from "framer-motion"
import { FileIcon, X } from "lucide-react"

interface FilePreviewProps {
  file: File
  onRemove?: () => void
}

export const FilePreview = React.forwardRef<HTMLDivElement, FilePreviewProps>(
  (props, ref) => {
    if (props.file.type.startsWith("image/")) {
      return <ImageFilePreview {...props} ref={ref} />
    }

    if (
      props.file.type.startsWith("text/") ||
      props.file.name.endsWith(".txt") ||
      props.file.name.endsWith(".md")
    ) {
      return <TextFilePreview {...props} ref={ref} />
    }

    return <GenericFilePreview {...props} ref={ref} />
  }
)
FilePreview.displayName = "FilePreview"

const ImageFilePreview = React.forwardRef<HTMLDivElement, FilePreviewProps>(
  ({ file, onRemove }, ref) => {
    return (
      <motion.div
        ref={ref}
        className="relative flex max-w-[200px] rounded-md border p-1.5 pr-2 text-xs"
        layout
        initial={{ opacity: 0, y: "100%" }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: "100%" }}
      >
        <div className="flex w-full items-center space-x-2">
          {/* eslint-disable-next-line @next/next/no-img-element */}
          <img
            alt={`Attachment ${file.name}`}
            className="grid h-10 w-10 shrink-0 place-items-center rounded-sm border bg-muted object-cover"
            src={URL.createObjectURL(file)}
          />
          <span className="w-full truncate text-muted-foreground">
            {file.name}
          </span>
        </div>

        {onRemove ? (
          <button
            className="absolute -right-2 -top-2 flex h-4 w-4 items-center justify-center rounded-full border bg-background"
            type="button"
            onClick={onRemove}
            aria-label="Remove attachment"
          >
            <X className="h-2.5 w-2.5" />
          </button>
        ) : null}
      </motion.div>
    )
  }
)
ImageFilePreview.displayName = "ImageFilePreview"

const TextFilePreview = React.forwardRef<HTMLDivElement, FilePreviewProps>(
  ({ file, onRemove }, ref) => {
    const [preview, setPreview] = React.useState<string>("")

    useEffect(() => {
      const reader = new FileReader()
      reader.onload = (e) => {
        const text = e.target?.result as string
        setPreview(text.slice(0, 50) + (text.length > 50 ? "..." : ""))
      }
      reader.readAsText(file)
    }, [file])

    return (
      <motion.div
        ref={ref}
        className="relative flex max-w-[200px] rounded-md border p-1.5 pr-2 text-xs"
        layout
        initial={{ opacity: 0, y: "100%" }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: "100%" }}
      >
        <div className="flex w-full items-center space-x-2">
          <div className="grid h-10 w-10 shrink-0 place-items-center rounded-sm border bg-muted p-0.5">
            <div className="h-full w-full overflow-hidden text-[6px] leading-none text-muted-foreground">
              {preview || "Loading..."}
            </div>
          </div>
          <span className="w-full truncate text-muted-foreground">
            {file.name}
          </span>
        </div>

        {onRemove ? (
          <button
            className="absolute -right-2 -top-2 flex h-4 w-4 items-center justify-center rounded-full border bg-background"
            type="button"
            onClick={onRemove}
            aria-label="Remove attachment"
          >
            <X className="h-2.5 w-2.5" />
          </button>
        ) : null}
      </motion.div>
    )
  }
)
TextFilePreview.displayName = "TextFilePreview"

const GenericFilePreview = React.forwardRef<HTMLDivElement, FilePreviewProps>(
  ({ file, onRemove }, ref) => {
    return (
      <motion.div
        ref={ref}
        className="relative flex max-w-[200px] rounded-md border p-1.5 pr-2 text-xs"
        layout
        initial={{ opacity: 0, y: "100%" }}
        animate={{ opacity: 1, y: 0 }}
        exit={{ opacity: 0, y: "100%" }}
      >
        <div className="flex w-full items-center space-x-2">
          <div className="grid h-10 w-10 shrink-0 place-items-center rounded-sm border bg-muted">
            <FileIcon className="h-6 w-6 text-foreground" />
          </div>
          <span className="w-full truncate text-muted-foreground">
            {file.name}
          </span>
        </div>

        {onRemove ? (
          <button
            className="absolute -right-2 -top-2 flex h-4 w-4 items-center justify-center rounded-full border bg-background"
            type="button"
            onClick={onRemove}
            aria-label="Remove attachment"
          >
            <X className="h-2.5 w-2.5" />
          </button>
        ) : null}
      </motion.div>
    )
  }
)
GenericFilePreview.displayName = "GenericFilePreview"



================================================
File: src/components/ui/input.tsx
================================================
import * as React from "react"

import { cn } from "@/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }



================================================
File: src/components/ui/interrupt-prompt.tsx
================================================
"use client"

import { AnimatePresence, motion } from "framer-motion"
import { X } from "lucide-react"

interface InterruptPromptProps {
  isOpen: boolean
  close: () => void
}

export function InterruptPrompt({ isOpen, close }: InterruptPromptProps) {
  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          initial={{ top: 0, filter: "blur(5px)" }}
          animate={{
            top: -40,
            filter: "blur(0px)",
            transition: {
              type: "spring",
              filter: { type: "tween" },
            },
          }}
          exit={{ top: 0, filter: "blur(5px)" }}
          className="absolute left-1/2 flex -translate-x-1/2 overflow-hidden whitespace-nowrap rounded-full border bg-background py-1 text-center text-sm text-muted-foreground"
        >
          <span className="ml-2.5">Press Enter again to interrupt</span>
          <button
            className="ml-1 mr-2.5 flex items-center"
            type="button"
            onClick={close}
            aria-label="Close"
          >
            <X className="h-3 w-3" />
          </button>
        </motion.div>
      )}
    </AnimatePresence>
  )
}



================================================
File: src/components/ui/label.tsx
================================================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }



================================================
File: src/components/ui/markdown-renderer.tsx
================================================
import React, { Suspense } from "react"
import Markdown from "react-markdown"
import remarkGfm from "remark-gfm"

import { cn } from "@/utils"
import { CopyButton } from "@/components/ui/copy-button"

interface MarkdownRendererProps {
  children: string
}

export function MarkdownRenderer({ children }: MarkdownRendererProps) {
  return (
    <div className="space-y-3">
      <Markdown remarkPlugins={[remarkGfm]} components={COMPONENTS}>
        {children}
      </Markdown>
    </div>
  )
}

interface HighlightedPre extends React.HTMLAttributes<HTMLPreElement> {
  children: string
  language: string
}

const HighlightedPre = React.memo(
  async ({ children, language, ...props }: HighlightedPre) => {
    const { codeToTokens, bundledLanguages } = await import("shiki")

    if (!(language in bundledLanguages)) {
      return <pre {...props}>{children}</pre>
    }

    const { tokens } = await codeToTokens(children, {
      lang: language as keyof typeof bundledLanguages,
      defaultColor: false,
      themes: {
        light: "github-light",
        dark: "github-dark",
      },
    })

    return (
      <pre {...props}>
        <code>
          {tokens.map((line, lineIndex) => (
            <>
              <span key={lineIndex}>
                {line.map((token, tokenIndex) => {
                  const style =
                    typeof token.htmlStyle === "string"
                      ? undefined
                      : token.htmlStyle

                  return (
                    <span
                      key={tokenIndex}
                      className="text-shiki-light bg-shiki-light-bg dark:text-shiki-dark dark:bg-shiki-dark-bg"
                      style={style}
                    >
                      {token.content}
                    </span>
                  )
                })}
              </span>
              {lineIndex !== tokens.length - 1 && "\n"}
            </>
          ))}
        </code>
      </pre>
    )
  }
)
HighlightedPre.displayName = "HighlightedCode"

interface CodeBlockProps extends React.HTMLAttributes<HTMLPreElement> {
  children: React.ReactNode
  className?: string
  language: string
}

const CodeBlock = ({
  children,
  className,
  language,
  ...restProps
}: CodeBlockProps) => {
  const code =
    typeof children === "string"
      ? children
      : childrenTakeAllStringContents(children)

  const preClass = cn(
    "overflow-x-scroll rounded-md border bg-background/50 p-4 font-mono text-sm [scrollbar-width:none]",
    className
  )

  return (
    <div className="group/code relative mb-4">
      <Suspense
        fallback={
          <pre className={preClass} {...restProps}>
            {children}
          </pre>
        }
      >
        <HighlightedPre language={language} className={preClass}>
          {code}
        </HighlightedPre>
      </Suspense>

      <div className="invisible absolute right-2 top-2 flex space-x-1 rounded-lg p-1 opacity-0 transition-all duration-200 group-hover/code:visible group-hover/code:opacity-100">
        <CopyButton content={code} copyMessage="Copied code to clipboard" />
      </div>
    </div>
  )
}

function childrenTakeAllStringContents(element: any): string {
  if (typeof element === "string") {
    return element
  }

  if (element?.props?.children) {
    let children = element.props.children

    if (Array.isArray(children)) {
      return children
        .map((child) => childrenTakeAllStringContents(child))
        .join("")
    } else {
      return childrenTakeAllStringContents(children)
    }
  }

  return ""
}

const COMPONENTS = {
  h1: withClass("h1", "text-2xl font-semibold"),
  h2: withClass("h2", "font-semibold text-xl"),
  h3: withClass("h3", "font-semibold text-lg"),
  h4: withClass("h4", "font-semibold text-base"),
  h5: withClass("h5", "font-medium"),
  strong: withClass("strong", "font-semibold"),
  a: withClass("a", "text-primary underline underline-offset-2"),
  blockquote: withClass("blockquote", "border-l-2 border-primary pl-4"),
  code: ({ children, className, node, ...rest }: any) => {
    const match = /language-(\w+)/.exec(className || "")
    return match ? (
      <CodeBlock className={className} language={match[1]} {...rest}>
        {children}
      </CodeBlock>
    ) : (
      <code
        className={cn(
          "font-mono [:not(pre)>&]:rounded-md [:not(pre)>&]:bg-background/50 [:not(pre)>&]:px-1 [:not(pre)>&]:py-0.5"
        )}
        {...rest}
      >
        {children}
      </code>
    )
  },
  pre: ({ children }: any) => children,
  ol: withClass("ol", "list-decimal space-y-2 pl-6"),
  ul: withClass("ul", "list-disc space-y-2 pl-6"),
  li: withClass("li", "my-1.5"),
  table: withClass(
    "table",
    "w-full border-collapse overflow-y-auto rounded-md border border-foreground/20"
  ),
  th: withClass(
    "th",
    "border border-foreground/20 px-4 py-2 text-left font-bold [&[align=center]]:text-center [&[align=right]]:text-right"
  ),
  td: withClass(
    "td",
    "border border-foreground/20 px-4 py-2 text-left [&[align=center]]:text-center [&[align=right]]:text-right"
  ),
  tr: withClass("tr", "m-0 border-t p-0 even:bg-muted"),
  p: withClass("p", "whitespace-pre-wrap"),
  hr: withClass("hr", "border-foreground/20"),
}

function withClass(Tag: keyof JSX.IntrinsicElements, classes: string) {
  const Component = ({ node, ...props }: any) => (
    <Tag className={classes} {...props} />
  )
  Component.displayName = Tag
  return Component
}

export default MarkdownRenderer



================================================
File: src/components/ui/message-input.tsx
================================================
"use client"

import React, { useEffect, useRef, useState } from "react"
import { AnimatePresence, motion } from "framer-motion"
import { ArrowUp, Info, Loader2, Mic, Paperclip, Square, X } from "lucide-react"
import { omit } from "remeda"

import { cn } from "@/utils"
import { useAudioRecording } from "@/hooks/use-audio-recording"
import { useAutosizeTextArea } from "@/hooks/use-autosize-textarea"
import { AudioVisualizer } from "@/components/ui/audio-visualizer"
import { Button } from "@/components/ui/button"
import { FilePreview } from "@/components/ui/file-preview"
import { InterruptPrompt } from "@/components/ui/interrupt-prompt"

interface MessageInputBaseProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  value: string
  submitOnEnter?: boolean
  stop?: () => void
  isGenerating: boolean
  enableInterrupt?: boolean
  transcribeAudio?: (blob: Blob) => Promise<string>
}

interface MessageInputWithoutAttachmentProps extends MessageInputBaseProps {
  allowAttachments?: false
}

interface MessageInputWithAttachmentsProps extends MessageInputBaseProps {
  allowAttachments: true
  files: File[] | null
  setFiles: React.Dispatch<React.SetStateAction<File[] | null>>
}

type MessageInputProps =
  | MessageInputWithoutAttachmentProps
  | MessageInputWithAttachmentsProps

export function MessageInput({
  placeholder = "Ask AI...",
  className,
  onKeyDown: onKeyDownProp,
  submitOnEnter = true,
  stop,
  isGenerating,
  enableInterrupt = true,
  transcribeAudio,
  ...props
}: MessageInputProps) {
  const [isDragging, setIsDragging] = useState(false)
  const [showInterruptPrompt, setShowInterruptPrompt] = useState(false)

  const {
    isListening,
    isSpeechSupported,
    isRecording,
    isTranscribing,
    audioStream,
    toggleListening,
    stopRecording,
  } = useAudioRecording({
    transcribeAudio,
    onTranscriptionComplete: (text) => {
      props.onChange?.({ target: { value: text } } as any)
    },
  })

  useEffect(() => {
    if (!isGenerating) {
      setShowInterruptPrompt(false)
    }
  }, [isGenerating])

  const addFiles = (files: File[] | null) => {
    if (props.allowAttachments) {
      props.setFiles((currentFiles) => {
        if (currentFiles === null) {
          return files
        }

        if (files === null) {
          return currentFiles
        }

        return [...currentFiles, ...files]
      })
    }
  }

  const onDragOver = (event: React.DragEvent) => {
    if (props.allowAttachments !== true) return
    event.preventDefault()
    setIsDragging(true)
  }

  const onDragLeave = (event: React.DragEvent) => {
    if (props.allowAttachments !== true) return
    event.preventDefault()
    setIsDragging(false)
  }

  const onDrop = (event: React.DragEvent) => {
    setIsDragging(false)
    if (props.allowAttachments !== true) return
    event.preventDefault()
    const dataTransfer = event.dataTransfer
    if (dataTransfer.files.length) {
      addFiles(Array.from(dataTransfer.files))
    }
  }

  const onPaste = (event: React.ClipboardEvent) => {
    const items = event.clipboardData?.items
    if (!items) return

    const text = event.clipboardData.getData("text")
    if (text && text.length > 500 && props.allowAttachments) {
      event.preventDefault()
      const blob = new Blob([text], { type: "text/plain" })
      const file = new File([blob], "Pasted text", {
        type: "text/plain",
        lastModified: Date.now(),
      })
      addFiles([file])
      return
    }

    const files = Array.from(items)
      .map((item) => item.getAsFile())
      .filter((file) => file !== null)

    if (props.allowAttachments && files.length > 0) {
      addFiles(files)
    }
  }

  const onKeyDown = (event: React.KeyboardEvent<HTMLTextAreaElement>) => {
    if (submitOnEnter && event.key === "Enter" && !event.shiftKey) {
      event.preventDefault()

      if (isGenerating && stop && enableInterrupt) {
        if (showInterruptPrompt) {
          stop()
          setShowInterruptPrompt(false)
          event.currentTarget.form?.requestSubmit()
        } else if (
          props.value ||
          (props.allowAttachments && props.files?.length)
        ) {
          setShowInterruptPrompt(true)
          return
        }
      }

      event.currentTarget.form?.requestSubmit()
    }

    onKeyDownProp?.(event)
  }

  const textAreaRef = useRef<HTMLTextAreaElement>(null)
  const [textAreaHeight, setTextAreaHeight] = useState<number>(0)

  useEffect(() => {
    if (textAreaRef.current) {
      setTextAreaHeight(textAreaRef.current.offsetHeight)
    }
  }, [props.value])

  const showFileList =
    props.allowAttachments && props.files && props.files.length > 0

  useAutosizeTextArea({
    ref: textAreaRef,
    maxHeight: 240,
    borderWidth: 1,
    dependencies: [props.value, showFileList],
  })

  return (
    <div
      className="relative flex w-full"
      onDragOver={onDragOver}
      onDragLeave={onDragLeave}
      onDrop={onDrop}
    >
      {enableInterrupt && (
        <InterruptPrompt
          isOpen={showInterruptPrompt}
          close={() => setShowInterruptPrompt(false)}
        />
      )}

      <RecordingPrompt
        isVisible={isRecording}
        onStopRecording={stopRecording}
      />

      <div className="relative flex w-full items-center space-x-2">
        <div className="relative flex-1">
          <textarea
            aria-label="Write your prompt here"
            placeholder={placeholder}
            ref={textAreaRef}
            onPaste={onPaste}
            onKeyDown={onKeyDown}
            className={cn(
              "z-10 w-full grow resize-none rounded-xl border border-input bg-background p-3 pr-24 text-sm ring-offset-background transition-[border] placeholder:text-muted-foreground focus-visible:border-primary focus-visible:outline-none disabled:cursor-not-allowed disabled:opacity-50",
              showFileList && "pb-16",
              className
            )}
            {...(props.allowAttachments
              ? omit(props, ["allowAttachments", "files", "setFiles"])
              : omit(props, ["allowAttachments"]))}
          />

          {props.allowAttachments && (
            <div className="absolute inset-x-3 bottom-0 z-20 overflow-x-scroll py-3">
              <div className="flex space-x-3">
                <AnimatePresence mode="popLayout">
                  {props.files?.map((file) => {
                    return (
                      <FilePreview
                        key={file.name + String(file.lastModified)}
                        file={file}
                        onRemove={() => {
                          props.setFiles((files) => {
                            if (!files) return null

                            const filtered = Array.from(files).filter(
                              (f) => f !== file
                            )
                            if (filtered.length === 0) return null
                            return filtered
                          })
                        }}
                      />
                    )
                  })}
                </AnimatePresence>
              </div>
            </div>
          )}
        </div>
      </div>

      <div className="absolute right-3 top-3 z-20 flex gap-2">
        {props.allowAttachments && (
          <Button
            type="button"
            size="icon"
            variant="outline"
            className="h-8 w-8"
            aria-label="Attach a file"
            onClick={async () => {
              const files = await showFileUploadDialog()
              addFiles(files)
            }}
          >
            <Paperclip className="h-4 w-4" />
          </Button>
        )}
        {isSpeechSupported && (
          <Button
            type="button"
            variant="outline"
            className={cn("h-8 w-8", isListening && "text-primary")}
            aria-label="Voice input"
            size="icon"
            onClick={toggleListening}
          >
            <Mic className="h-4 w-4" />
          </Button>
        )}
        {isGenerating && stop ? (
          <Button
            type="button"
            size="icon"
            className="h-8 w-8"
            aria-label="Stop generating"
            onClick={stop}
          >
            <Square className="h-3 w-3 animate-pulse" fill="currentColor" />
          </Button>
        ) : (
          <Button
            type="submit"
            size="icon"
            className="h-8 w-8 transition-opacity"
            aria-label="Send message"
            disabled={props.value === "" || isGenerating}
          >
            <ArrowUp className="h-5 w-5" />
          </Button>
        )}
      </div>

      {props.allowAttachments && <FileUploadOverlay isDragging={isDragging} />}

      <RecordingControls
        isRecording={isRecording}
        isTranscribing={isTranscribing}
        audioStream={audioStream}
        textAreaHeight={textAreaHeight}
        onStopRecording={stopRecording}
      />
    </div>
  )
}
MessageInput.displayName = "MessageInput"

interface FileUploadOverlayProps {
  isDragging: boolean
}

function FileUploadOverlay({ isDragging }: FileUploadOverlayProps) {
  return (
    <AnimatePresence>
      {isDragging && (
        <motion.div
          className="pointer-events-none absolute inset-0 z-20 flex items-center justify-center space-x-2 rounded-xl border border-dashed border-border bg-background text-sm text-muted-foreground"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
          transition={{ duration: 0.2 }}
          aria-hidden
        >
          <Paperclip className="h-4 w-4" />
          <span>Drop your files here to attach them.</span>
        </motion.div>
      )}
    </AnimatePresence>
  )
}

function showFileUploadDialog() {
  const input = document.createElement("input")

  input.type = "file"
  input.multiple = true
  input.accept = "*/*"
  input.click()

  return new Promise<File[] | null>((resolve) => {
    input.onchange = (e) => {
      const files = (e.currentTarget as HTMLInputElement).files

      if (files) {
        resolve(Array.from(files))
        return
      }

      resolve(null)
    }
  })
}

function TranscribingOverlay() {
  return (
    <motion.div
      className="flex h-full w-full flex-col items-center justify-center rounded-xl bg-background/80 backdrop-blur-sm"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      transition={{ duration: 0.2 }}
    >
      <div className="relative">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <motion.div
          className="absolute inset-0 h-8 w-8 animate-pulse rounded-full bg-primary/20"
          initial={{ scale: 0.8, opacity: 0 }}
          animate={{ scale: 1.2, opacity: 1 }}
          transition={{
            duration: 1,
            repeat: Infinity,
            repeatType: "reverse",
            ease: "easeInOut",
          }}
        />
      </div>
      <p className="mt-4 text-sm font-medium text-muted-foreground">
        Transcribing audio...
      </p>
    </motion.div>
  )
}

interface RecordingPromptProps {
  isVisible: boolean
  onStopRecording: () => void
}

function RecordingPrompt({ isVisible, onStopRecording }: RecordingPromptProps) {
  return (
    <AnimatePresence>
      {isVisible && (
        <motion.div
          initial={{ top: 0, filter: "blur(5px)" }}
          animate={{
            top: -40,
            filter: "blur(0px)",
            transition: {
              type: "spring",
              filter: { type: "tween" },
            },
          }}
          exit={{ top: 0, filter: "blur(5px)" }}
          className="absolute left-1/2 flex -translate-x-1/2 cursor-pointer overflow-hidden whitespace-nowrap rounded-full border bg-background py-1 text-center text-sm text-muted-foreground"
          onClick={onStopRecording}
        >
          <span className="mx-2.5 flex items-center">
            <Info className="mr-2 h-3 w-3" />
            Click to finish recording
          </span>
        </motion.div>
      )}
    </AnimatePresence>
  )
}

interface RecordingControlsProps {
  isRecording: boolean
  isTranscribing: boolean
  audioStream: MediaStream | null
  textAreaHeight: number
  onStopRecording: () => void
}

function RecordingControls({
  isRecording,
  isTranscribing,
  audioStream,
  textAreaHeight,
  onStopRecording,
}: RecordingControlsProps) {
  if (isRecording) {
    return (
      <div
        className="absolute inset-[1px] z-50 overflow-hidden rounded-xl"
        style={{ height: textAreaHeight - 2 }}
      >
        <AudioVisualizer
          stream={audioStream}
          isRecording={isRecording}
          onClick={onStopRecording}
        />
      </div>
    )
  }

  if (isTranscribing) {
    return (
      <div
        className="absolute inset-[1px] z-50 overflow-hidden rounded-xl"
        style={{ height: textAreaHeight - 2 }}
      >
        <TranscribingOverlay />
      </div>
    )
  }

  return null
}



================================================
File: src/components/ui/message-list.tsx
================================================
import {
  ChatMessage,
  type ChatMessageProps,
  type Message,
} from "@/components/ui/chat-message"
import { TypingIndicator } from "@/components/ui/typing-indicator"

type AdditionalMessageOptions = Omit<ChatMessageProps, keyof Message>

interface MessageListProps {
  messages: Message[]
  showTimeStamps?: boolean
  isTyping?: boolean
  messageOptions?:
    | AdditionalMessageOptions
    | ((message: Message) => AdditionalMessageOptions)
}

export function MessageList({
  messages,
  showTimeStamps = true,
  isTyping = false,
  messageOptions,
}: MessageListProps) {
  return (
    <div className="space-y-4 overflow-visible">
      {messages.map((message, index) => {
        const additionalOptions =
          typeof messageOptions === "function"
            ? messageOptions(message)
            : messageOptions

        return (
          <ChatMessage
            key={index}
            showTimeStamp={showTimeStamps}
            {...message}
            {...additionalOptions}
          />
        )
      })}
      {isTyping && <TypingIndicator />}
    </div>
  )
}



================================================
File: src/components/ui/prompt-suggestions.tsx
================================================
interface PromptSuggestionsProps {
  label: string
  append: (message: { role: "user"; content: string }) => void
  suggestions: string[]
}

export function PromptSuggestions({
  label,
  append,
  suggestions,
}: PromptSuggestionsProps) {
  return (
    <div className="space-y-6">
      <h2 className="text-center text-2xl font-bold">{label}</h2>
      <div className="flex gap-6 text-sm">
        {suggestions.map((suggestion) => (
          <button
            key={suggestion}
            onClick={() => append({ role: "user", content: suggestion })}
            className="h-max flex-1 rounded-xl border bg-background p-4 hover:bg-muted"
          >
            <p>{suggestion}</p>
          </button>
        ))}
      </div>
    </div>
  )
}



================================================
File: src/components/ui/sonner.tsx
================================================
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner, ToasterProps } from "sonner"

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      style={
        {
          "--normal-bg": "var(--popover)",
          "--normal-text": "var(--popover-foreground)",
          "--normal-border": "var(--border)",
        } as React.CSSProperties
      }
      {...props}
    />
  )
}

export { Toaster }



================================================
File: src/components/ui/textarea.tsx
================================================
import * as React from "react"

import { cn } from "@/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }



================================================
File: src/components/ui/typing-indicator.tsx
================================================
import { Dot } from "lucide-react"

export function TypingIndicator() {
  return (
    <div className="justify-left flex space-x-1">
      <div className="rounded-lg bg-muted p-3">
        <div className="flex -space-x-2.5">
          <Dot className="h-5 w-5 animate-typing-dot-bounce" />
          <Dot className="h-5 w-5 animate-typing-dot-bounce [animation-delay:90ms]" />
          <Dot className="h-5 w-5 animate-typing-dot-bounce [animation-delay:180ms]" />
        </div>
      </div>
    </div>
  )
}



================================================
File: src/hooks/use-audio-recording.ts
================================================
import { useEffect, useRef, useState } from "react"

import { recordAudio } from "@/components/lib/audio-utils"

interface UseAudioRecordingOptions {
  transcribeAudio?: (blob: Blob) => Promise<string>
  onTranscriptionComplete?: (text: string) => void
}

export function useAudioRecording({
  transcribeAudio,
  onTranscriptionComplete,
}: UseAudioRecordingOptions) {
  const [isListening, setIsListening] = useState(false)
  const [isSpeechSupported, setIsSpeechSupported] = useState(!!transcribeAudio)
  const [isRecording, setIsRecording] = useState(false)
  const [isTranscribing, setIsTranscribing] = useState(false)
  const [audioStream, setAudioStream] = useState<MediaStream | null>(null)
  const activeRecordingRef = useRef<any>(null)

  useEffect(() => {
    const checkSpeechSupport = async () => {
      const hasMediaDevices = !!(
        navigator.mediaDevices && navigator.mediaDevices.getUserMedia
      )
      setIsSpeechSupported(hasMediaDevices && !!transcribeAudio)
    }

    checkSpeechSupport()
  }, [transcribeAudio])

  const stopRecording = async () => {
    setIsRecording(false)
    setIsTranscribing(true)
    try {
      // First stop the recording to get the final blob
      recordAudio.stop()
      // Wait for the recording promise to resolve with the final blob
      const recording = await activeRecordingRef.current
      if (transcribeAudio) {
        const text = await transcribeAudio(recording)
        onTranscriptionComplete?.(text)
      }
    } catch (error) {
      console.error("Error transcribing audio:", error)
    } finally {
      setIsTranscribing(false)
      setIsListening(false)
      if (audioStream) {
        audioStream.getTracks().forEach((track) => track.stop())
        setAudioStream(null)
      }
      activeRecordingRef.current = null
    }
  }

  const toggleListening = async () => {
    if (!isListening) {
      try {
        setIsListening(true)
        setIsRecording(true)
        // Get audio stream first
        const stream = await navigator.mediaDevices.getUserMedia({
          audio: true,
        })
        setAudioStream(stream)

        // Start recording with the stream
        activeRecordingRef.current = recordAudio(stream)
      } catch (error) {
        console.error("Error recording audio:", error)
        setIsListening(false)
        setIsRecording(false)
        if (audioStream) {
          audioStream.getTracks().forEach((track) => track.stop())
          setAudioStream(null)
        }
      }
    } else {
      await stopRecording()
    }
  }

  return {
    isListening,
    isSpeechSupported,
    isRecording,
    isTranscribing,
    audioStream,
    toggleListening,
    stopRecording,
  }
}



================================================
File: src/hooks/use-auto-scroll.ts
================================================
import { useEffect, useRef, useState } from "react"

// How many pixels from the bottom of the container to enable auto-scroll
const ACTIVATION_THRESHOLD = 50
// Minimum pixels of scroll-up movement required to disable auto-scroll
const MIN_SCROLL_UP_THRESHOLD = 10

export function useAutoScroll(dependencies: React.DependencyList) {
  const containerRef = useRef<HTMLDivElement | null>(null)
  const previousScrollTop = useRef<number | null>(null)
  const [shouldAutoScroll, setShouldAutoScroll] = useState(true)

  const scrollToBottom = () => {
    if (containerRef.current) {
      containerRef.current.scrollTop = containerRef.current.scrollHeight
    }
  }

  const handleScroll = () => {
    if (containerRef.current) {
      const { scrollTop, scrollHeight, clientHeight } = containerRef.current

      const distanceFromBottom = Math.abs(
        scrollHeight - scrollTop - clientHeight
      )

      const isScrollingUp = previousScrollTop.current
        ? scrollTop < previousScrollTop.current
        : false

      const scrollUpDistance = previousScrollTop.current
        ? previousScrollTop.current - scrollTop
        : 0

      const isDeliberateScrollUp =
        isScrollingUp && scrollUpDistance > MIN_SCROLL_UP_THRESHOLD

      if (isDeliberateScrollUp) {
        setShouldAutoScroll(false)
      } else {
        const isScrolledToBottom = distanceFromBottom < ACTIVATION_THRESHOLD
        setShouldAutoScroll(isScrolledToBottom)
      }

      previousScrollTop.current = scrollTop
    }
  }

  const handleTouchStart = () => {
    setShouldAutoScroll(false)
  }

  useEffect(() => {
    if (containerRef.current) {
      previousScrollTop.current = containerRef.current.scrollTop
    }
  }, [])

  useEffect(() => {
    if (shouldAutoScroll) {
      scrollToBottom()
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, dependencies)

  return {
    containerRef,
    scrollToBottom,
    handleScroll,
    shouldAutoScroll,
    handleTouchStart,
  }
}



================================================
File: src/hooks/use-autosize-textarea.ts
================================================
import { useLayoutEffect, useRef } from "react"

interface UseAutosizeTextAreaProps {
  ref: React.RefObject<HTMLTextAreaElement>
  maxHeight?: number
  borderWidth?: number
  dependencies: React.DependencyList
}

export function useAutosizeTextArea({
  ref,
  maxHeight = Number.MAX_SAFE_INTEGER,
  borderWidth = 0,
  dependencies,
}: UseAutosizeTextAreaProps) {
  const originalHeight = useRef<number | null>(null)

  useLayoutEffect(() => {
    if (!ref.current) return

    const currentRef = ref.current
    const borderAdjustment = borderWidth * 2

    if (originalHeight.current === null) {
      originalHeight.current = currentRef.scrollHeight - borderAdjustment
    }

    currentRef.style.removeProperty("height")
    const scrollHeight = currentRef.scrollHeight

    // Make sure we don't go over maxHeight
    const clampedToMax = Math.min(scrollHeight, maxHeight)
    // Make sure we don't go less than the original height
    const clampedToMin = Math.max(clampedToMax, originalHeight.current)

    currentRef.style.height = `${clampedToMin + borderAdjustment}px`
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [maxHeight, ref, ...dependencies])
}



================================================
File: src/hooks/use-copy-to-clipboard.ts
================================================
import { useCallback, useRef, useState } from "react"
import { toast } from "sonner"

type UseCopyToClipboardProps = {
  text: string
  copyMessage?: string
}

export function useCopyToClipboard({
  text,
  copyMessage = "Copied to clipboard!",
}: UseCopyToClipboardProps) {
  const [isCopied, setIsCopied] = useState(false)
  const timeoutRef = useRef<NodeJS.Timeout | null>(null)

  const handleCopy = useCallback(() => {
    navigator.clipboard
      .writeText(text)
      .then(() => {
        toast.success(copyMessage)
        setIsCopied(true)
        if (timeoutRef.current) {
          clearTimeout(timeoutRef.current)
          timeoutRef.current = null
        }
        timeoutRef.current = setTimeout(() => {
          setIsCopied(false)
        }, 2000)
      })
      .catch(() => {
        toast.error("Failed to copy to clipboard.")
      })
  }, [text, copyMessage])

  return { isCopied, handleCopy }
}



================================================
File: src/store/index.ts
================================================
// src/store/index.ts
import { create } from 'zustand';
import { toast } from 'sonner';

type Step = "problem" | "lesson" | "examples" | "quizzes" | "end";
interface AppState {
  step: Step;
  sessionId: string | null;
  problem: string;
  images: File[];
  imageUrls: string[];
  lesson: string | null;
  examples: any;
  quiz: any;
  error: string | null;
  loading: boolean;
  quizAnswer: string;
  quizFeedback: any;
  messages: Array<{ role: "user" | "assistant"; content: string; renderAs?: "markdown" | "html" }>;
  hasSubmittedProblem: boolean;
  set: (updates: Partial<AppState>) => void;
  setStep: (step: Step) => void;
  addMessage: (message: { role: string; content: string; renderAs?: "markdown" | "html" }) => void;
  handleSubmit: (problem: string, imageUrls: string[]) => Promise<void>;
  handleExamplesRequest: () => Promise<void>;
  handleQuizSubmit: () => Promise<void>;
  handleValidate: (answer: string, quiz: any) => Promise<void>;
  append: (message: { role: string; content: string }, imageUrls: string[]) => Promise<void>;
  reset: () => void;
}

const useAppStore = create<AppState>((set, get) => ({
  step: 'problem',
  sessionId: null,
  problem: '',
  images: [],
  imageUrls: [],
  lesson: null,
  examples: null,
  quiz: null,
  error: null,
  loading: false,
  quizAnswer: '',
  quizFeedback: null,
  messages: [],
  hasSubmittedProblem: false,
  set: (updates) => set(updates),
  setStep: (step) => set({ step }),
  addMessage: (msg) => set((s) => ({ messages: [...s.messages, msg] })),
  handleSubmit: async (problem, imageUrls) => {
    const { sessionId, addMessage } = get();
    set({ loading: true, problem, imageUrls, hasSubmittedProblem: true });
    try {
      addMessage({ role: "user", content: problem });
      const token = document.cookie
        .split("; ")
        .find(row => row.startsWith("supabase-auth-token="))
        ?.split("=")[1];
      const headers: HeadersInit = {
        "Content-Type": "application/json",
        "x-session-id": sessionId || "",
      };
      if (token) {
        headers["Authorization"] = `Bearer ${token}`;
      }
      const res = await fetch("/api/tutor", {
        method: "POST",
        headers,
        body: JSON.stringify({ problem, images: imageUrls }),
      });

      const lessonContent = await res.text();

      set({
        sessionId: res.headers.get("x-session-id") || sessionId,
        lesson: lessonContent,
        step: "lesson",
      });
      addMessage({ role: "assistant", content: lessonContent, renderAs: "html" });
    } catch (err) {
      console.error("Error in handleSubmit:", err);
      const errorMsg = err.message || "Failed to fetch lesson";
      set({ error: errorMsg });
      toast.error(errorMsg);
    } finally {
      set({ loading: false });
    }
  },
  handleExamplesRequest: async () => {
    const { problem, imageUrls, sessionId, addMessage } = get();
    set({ loading: true });
    try {
      addMessage({ role: "user", content: "Request Example" });
      const token = document.cookie
        .split("; ")
        .find(row => row.startsWith("supabase-auth-token="))
        ?.split("=")[1];
      const headers: HeadersInit = {
        "Content-Type": "application/json",
        "x-session-id": sessionId || "",
      };
      if (token) {
        headers["Authorization"] = `Bearer ${token}`;
      }
      const res = await fetch("/api/examples", {
        method: "POST",
        headers,
        body: JSON.stringify({ problem, images: imageUrls }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "Failed to fetch examples");
      set({ examples: data, step: "examples" });
      addMessage({
        role: "assistant",
        content: `**Example:**\n\n${data.problem}\n\n${data.solution.map((s: any) => `**${s.title}:** ${s.content}`).join("\n\n")}`,
      });
    } catch (err) {
      set({ error: err.message || "Failed to fetch examples" });
    } finally {
      set({ loading: false });
    }
  },
  handleQuizSubmit: async () => {
    const { problem, imageUrls, sessionId, addMessage } = get();
    set({ loading: true, step: "quizzes" });
    try {
      addMessage({ role: "user", content: "Take a Quiz" });
      const token = document.cookie
        .split("; ")
        .find(row => row.startsWith("supabase-auth-token="))
        ?.split("=")[1];
      const headers: HeadersInit = {
        "Content-Type": "application/json",
        "x-session-id": sessionId || "",
      };
      if (token) {
        headers["Authorization"] = `Bearer ${token}`;
      }
      const res = await fetch("/api/quiz", {
        method: "POST",
        headers,
        body: JSON.stringify({ problem, images: imageUrls }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "Failed to fetch quiz");
      set({ quiz: data, quizAnswer: '', quizFeedback: null });
      addMessage({
        role: "assistant",
        content: `<strong>Quiz:</strong><br>${data.problem}<br><ul>${data.options.map((o: string) => `<li>${o}</li>`).join("")}</ul>`,
        renderAs: "html",
      });
    } catch (err) {
      set({ error: err.message || "Failed to fetch quiz" });
    } finally {
      set({ loading: false });
    }
  },
  handleValidate: async (answer, quiz) => {
    const { sessionId, addMessage } = get();
    set({ loading: true });
    try {
      const token = document.cookie
        .split("; ")
        .find(row => row.startsWith("supabase-auth-token="))
        ?.split("=")[1];
      const headers: HeadersInit = {
        "Content-Type": "application/json",
        "x-session-id": sessionId || "",
      };
      if (token) {
        headers["Authorization"] = `Bearer ${token}`;
      }
      const res = await fetch("/api/validate", {
        method: "POST",
        headers,
        body: JSON.stringify({ sessionId, problem: quiz.problem, answer }),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "Failed to validate quiz");

      const isCorrect = answer === quiz.correctAnswer;
      const readinessConfidence = isCorrect
        ? quiz.readiness.confidenceIfCorrect
        : quiz.readiness.confidenceIfIncorrect;
      const readinessPercentage = Math.round(readinessConfidence * 100);

      let motivationalMessage = "";
      if (readinessPercentage >= 90) {
        motivationalMessage = "You're doing amazing! You're very likely to ace your big test!";
      } else if (readinessPercentage >= 70) {
        motivationalMessage = "Great progress! You're on track to do well on your big test. Keep practicing!";
      } else if (readinessPercentage >= 50) {
        motivationalMessage = "You're making progress! Let's keep working to boost your confidence for the big test.";
      } else {
        motivationalMessage = "Let's keep practicing! More effort will help you succeed on your big test.";
      }

      set({ quizAnswer: answer, quizFeedback: data });
      addMessage({
        role: "assistant",
        content: `<strong>Feedback:</strong><br><strong>Your Answer:</strong> ${answer}<br>${data.commentary}${data.solution ? `<br><br>${data.solution.map((s: any) => `<strong>${s.title}:</strong> ${s.content}`).join("<br><br>")}` : ""}<br><br><strong>Options:</strong><br><ul>${quiz.options.map((o: string) => `<li>${o}${o === answer ? " (Your answer)" : ""}${o === quiz.correctAnswer ? " (Correct answer)" : ""}</li>`).join("")}</ul><br><br><strong>Test Readiness:</strong><br><div class="readiness-container"><div class="readiness-bar" style="width: ${readinessPercentage}%"></div></div><p>${readinessPercentage}% - ${motivationalMessage}</p>`,
        renderAs: "html",
      });
    } catch (err) {
      set({ error: err.message || "Failed to validate quiz" });
      throw err;
    } finally {
      set({ loading: false });
    }
  },
  append: async (msg, imageUrls) => {
    const { handleSubmit } = get();
    await handleSubmit(msg.content, imageUrls);
  },
  reset: () => set({
    step: 'problem', sessionId: null, problem: '', images: [], imageUrls: [],
    lesson: null, examples: null, quiz: null, error: null,
    loading: false, quizAnswer: '', quizFeedback: null, messages: [],
    hasSubmittedProblem: false,
  }),
}));

export default useAppStore;


================================================
File: src/supabase/browserClient.ts
================================================
import { createClient } from "@supabase/supabase-js";

// Browser-side Supabase client (uses anon key)
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

// Runtime check to ensure the service role key is not used in the browser
if (typeof window !== "undefined" && process.env.SUPABASE_SERVICE_ROLE_KEY) {
  throw new Error("Security violation: SUPABASE_SERVICE_ROLE_KEY is exposed in the browser. This key must only be used in server-side code.");
}

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error("Missing Supabase environment variables. Ensure NEXT_PUBLIC_SUPABASE_URL and NEXT_PUBLIC_SUPABASE_ANON_KEY are set in your .env.local file.");
}

const supabase = createClient(supabaseUrl, supabaseAnonKey);

export default supabase;


================================================
File: src/supabase/config.toml
================================================
# Supabase configuration for local development
[api]
enabled = true
port = 54321
schemas = ["public"]
extra_search_path = ["public"]
max_rows = 1000

[db]
enabled = true
port = 54322
major_version = 14

[db.pooler]
enabled = false
port = 54329

[realtime]
enabled = true
port = 54323

[storage]
enabled = true
port = 54324
file_size_limit = 52428800  # 50MB file size limit for uploads

[auth]
enabled = true
port = 54325
external = ["email"]

[auth.email]
enabled = true
double_confirm_changes = true
enable_signup = true

[functions]
enabled = true
port = 54326

[functions.execute-sql]
enabled = true


================================================
File: src/supabase/serverClient.ts
================================================
import { createClient } from "@supabase/supabase-js";

// Server-side Supabase client (uses service role key)
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseServiceRoleKey = process.env.SUPABASE_SERVICE_ROLE_KEY;

// Runtime check to ensure this client is only used in server-side code
if (typeof window !== "undefined") {
  throw new Error("Security violation: Server-side Supabase client is being used in the browser. Use the browserClient instead.");
}

if (!supabaseUrl || !supabaseServiceRoleKey) {
  throw new Error("Missing Supabase environment variables. Ensure NEXT_PUBLIC_SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY are set in your .env.local file.");
}

const supabase = createClient(supabaseUrl, supabaseServiceRoleKey);

export default supabase;


================================================
File: src/supabase/functions/local-sql.sql
================================================
-- src/supabase/functions/local-sql.sql
-- Placeholder for a local PostgreSQL function
-- Note: The k12beast app currently uses the `execute-sql` edge function to execute SQL commands.
-- If you want to define a local PostgreSQL function, you can add it here and apply it using a migration.

-- Function to execute SQL commands (used by the execute-sql Edge Function)
CREATE OR REPLACE FUNCTION execute_sql(sql_text TEXT)
RETURNS VOID AS $$
BEGIN
  EXECUTE sql_text;
EXCEPTION WHEN OTHERS THEN
  RAISE EXCEPTION 'Error executing SQL: %', SQLERRM;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant permissions to the function (adjust based on your security requirements)
GRANT EXECUTE ON FUNCTION execute_sql TO postgres;

-- Grant additional permissions to the postgres role
GRANT ALL PRIVILEGES ON SCHEMA public TO postgres;
GRANT ALL PRIVILEGES ON TABLE sessions TO postgres;
GRANT USAGE ON SCHEMA auth TO postgres;
GRANT SELECT ON TABLE auth.users TO postgres;

-- Function to validate a user ID exists in auth.users
CREATE OR REPLACE FUNCTION public.validate_user_id(user_id UUID)
RETURNS BOOLEAN AS $$
BEGIN
  RETURN EXISTS (SELECT 1 FROM auth.users WHERE id = user_id);
EXCEPTION WHEN OTHERS THEN
  RAISE EXCEPTION 'Error validating user ID: %', SQLERRM;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Grant execute permission to the postgres role (used by Edge Functions)
GRANT EXECUTE ON FUNCTION public.validate_user_id(UUID) TO postgres;

-- Ensure the postgres role can access the public schema
GRANT USAGE ON SCHEMA public TO postgres;

-- Note: The foreign key constraint on sessions(user_id) allows NULL values by default,
-- meaning existing sessions can have a NULL user_id until they are updated.


================================================
File: src/supabase/functions/execute-sql/index.ts
================================================
// Deno runtime is used for Supabase Edge Functions
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2';
import { serve } from 'https://deno.land/std@0.131.0/http/server.ts';

// Define the expected request body type
interface SqlRequest {
  sql_text: string;
}

// Initialize Supabase client with service role key for full permissions
const supabaseUrl = Deno.env.get('SUPABASE_URL') ?? '';
const supabaseServiceRoleKey = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? '';

if (!supabaseUrl || !supabaseServiceRoleKey) {
  console.error('Missing Supabase environment variables: SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY must be set.');
  throw new Error('Missing Supabase environment variables: SUPABASE_URL and SUPABASE_SERVICE_ROLE_KEY must be set.');
}

const supabase = createClient(supabaseUrl, supabaseServiceRoleKey);

// Define CORS headers
const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',
  'Access-Control-Allow-Methods': 'POST, OPTIONS'
};

// Handle CORS preflight requests
function handleOptions() {
  console.log('Handling OPTIONS request');
  return new Response(null, {
    status: 204,
    headers: corsHeaders,
  });
}

// Main handler for the edge function
serve(async (req) => {
  console.log('Received request:', req.method, req.url);

  // Handle CORS preflight requests
  if (req.method === 'OPTIONS') {
    return handleOptions();
  }

  // Only allow POST requests
  if (req.method !== 'POST') {
    console.error('Method not allowed:', req.method);
    return new Response(JSON.stringify({ error: 'Method not allowed' }), {
      status: 405,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }

  try {
    // Parse the request body
    console.log('Parsing request body');
    const body: SqlRequest = await req.json();
    const { sql_text } = body;

    if (!sql_text) {
      console.error('Missing sql_text in request body');
      return new Response(JSON.stringify({ error: 'Missing sql_text in request body' }), {
        status: 400,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    console.log('Executing SQL:', sql_text);

    // Execute the SQL command using Supabase's `rpc` with the correct parameter name
    const { error } = await supabase.rpc('execute_sql', { sql_text: sql_text });

    if (error) {
      console.error('SQL execution failed:', JSON.stringify(error, null, 2));
      return new Response(JSON.stringify({ success: false, error: error.message }), {
        status: 500,
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      });
    }

    console.log('SQL executed successfully');
    return new Response(JSON.stringify({ success: true, data: null }), {
      status: 200,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  } catch (err) {
    console.error('Unexpected error in execute-sql Edge Function:', err.message, err.stack);
    return new Response(JSON.stringify({ success: false, error: err.message }), {
      status: 500,
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
    });
  }
});



================================================
File: src/utils/errorHandler.ts
================================================
import { NextResponse } from "next/server";

/**
 * Handles API errors and returns an appropriate HTTP response.
 * @param error - The error object caught from the API call.
 * @param routeName - The name of the route for logging purposes.
 * @returns A NextResponse object with the appropriate status code and error message.
 */
export function handleApiError(error: any, routeName: string): NextResponse {
  console.error(`Error in ${routeName} route:`, error);

  // Check for authentication errors
  if (error.message.includes("Authentication failed")) {
    return NextResponse.json({ error: error.message }, { status: 401 });
  }

  // Fallback for other errors
  return NextResponse.json({ error: error.message || "Internal server error" }, { status: 500 });
}


================================================
File: src/utils/index.ts
================================================
// src/utils/index.ts
import { type ClassValue, clsx } from "clsx";
import { twMerge } from "tailwind-merge";

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}


================================================
File: src/utils/xaiClient.ts
================================================
// src/utils/xaiClient.ts
import OpenAI from "openai";
import { validateRequestInputs } from "./xaiUtils";

const openai = new OpenAI({
  apiKey: process.env.XAI_API_KEY,
  baseURL: "https://api.x.ai/v1",
});

interface XAIResponse {
  isK12?: boolean;
  error?: string;
  lesson?: string;
  problem?: string;
  solution?: { title: string; content: string }[];
  answerFormat?: string;
  options?: string[];
  correctAnswer?: string;
  readiness?: { confidenceIfCorrect: number; confidenceIfIncorrect: number };
}

interface XAIRequestOptions {
  problem?: string;
  images?: string[];
  responseFormat: string;
  defaultResponse: XAIResponse;
  maxTokens?: number;
  validateK12?: boolean;
  chatHistory?: { role: string; content: string; renderAs?: "markdown" | "html" }[];
}

export async function sendXAIRequest(options: XAIRequestOptions): Promise<XAIResponse> {
  const {
    problem,
    images,
    responseFormat,
    defaultResponse,
    maxTokens = 1000,
    validateK12 = false,
    chatHistory = [],
  } = options;

  validateRequestInputs(problem, images);

  // Format the chat history
  const chatHistoryText = chatHistory.length > 0
    ? `Chat History:\n${chatHistory.map(msg =>
      `${msg.role === "user" ? "User" : "Assistant"}: ${msg.content}`).join("\n")}`
    : "No chat history available.";

  const messages: any[] = [
    {
      role: "system",
      content: `You are a K12 tutor. Assist with educational queries related to K12 subjects.
Respond only to valid K12 queries using the chat history for context. 
Respond in a conversational style as if you are speaking directly with a K12 student.
Return a raw JSON object
(formatted for JSON.parse()) with response fields in 
a string with plain text or minimal HTML formatting (use only <p>, <strong>, <ul>, <li> tags, no attributes or scripts). 
Ensure all quotes are escaped (e.g., \") and no raw control characters are included.
Do not wrap the JSON in Markdown code blocks (e.g., no \`\`\`json).`,
    },
    {
      role: "user",
      content: `Instructions: Use the provided chat history to understand the student's progress, including past lessons, examples, quiz results, and interactions. Infer the student's approximate age, grade level, and skill level (beginner, intermediate, advanced) from the chat history. Adapt your response based on this history—e.g., avoid repeating examples or quiz problems already given (as specified in the chat history), and adjust difficulty based on performance trends. If the chat history includes quiz responses, adjust the difficulty: provide more challenging content if the student answered correctly, or simpler content if they answered incorrectly.`,
    },
    {
      role: "user",
      content: `Original Input Problem (if provided): "${problem || 'No text provided'}"`,
    },
    {
      role: "user",
      content: chatHistoryText,
    },
    {
      role: "user",
      content: responseFormat,
    },
  ];

  if (images && images.length > 0) {
    messages.push({
      role: "user",
      content: images.map((url: string) => ({
        type: "image_url",
        image_url: { url },
      })),
    });
  }

  const requestPayload = {
    model: process.env.XAI_MODEL_NAME || "grok-2-vision-1212",
    messages,
    max_tokens: maxTokens,
  };
  console.log("Full xAI API request:", JSON.stringify(requestPayload, null, 2));

  const maxRetries = 3;
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const response = await openai.chat.completions.create(requestPayload);
      console.log("Full xAI API response:", JSON.stringify(response, null, 2));

      let rawContent = response.choices[0].message.content.trim();

      let content: XAIResponse;
      content = JSON.parse(rawContent);

      console.log("xAI API response content object:", content);

      return content;
    } catch (error) {
      if (attempt === maxRetries) throw error;
      console.warn(`xAI request failed (attempt ${attempt}/${maxRetries}):`, error.message);
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }
  throw new Error("Failed to get a response after maximum retries");
}

export { handleXAIError } from "./xaiUtils"; // Re-export for convenience


================================================
File: src/utils/xaiUtils.ts
================================================
import { NextResponse } from "next/server";

export function validateRequestInputs(problem?: string, images?: string[]) {
  if (!problem && (!images || images.length === 0)) {
    throw new Error("Missing problem or images");
  }
}

export function handleXAIError(error: any) {
  console.error("Error in xAI request:", error.message);
  return NextResponse.json(
    { error: error.message || "Unexpected error in xAI request" },
    { status: error.message === "Prompt must be related to K12 education" ? 400 : 500 }
  );
}

